                         4 .list
                         5 ** EECS-Exp II/III software-exp-I
                         6 ** v1.0 / 2023-11-15
                         7 ** Group 4
                         8 ** 1TE21022R Seo Ichika, 	1TE21143S Miyata Yusaku, 	1TE21940P Saitoh Koshi
                         9 ** 1TE21913T Takeishi Kota,	1TE21033K Goto Aoto,		1TE21057R Morokuma Haruto
                        10 
                        11 ** INDEX
                        12 ** STEP 1: 初期化ルーチン
                        13 ** STEP 4-2: INTERUT INTERFACE
                        14 ** STEP 6-3: INTERGET INTERFACE
                        15 ** STEP 0-1: キューの初期化ルーチン(1/2)
                        16 ** STEP 0-2: キューへの入力(INQ), 出力(OUTQ) ルーチン 
                        17 ** STEP 4-1: INTERPUT
                        18 ** STEP 5-1: PUTSTRING
                        19 ** STEP 6-1: GETSTRING
                        20 ** STEP 6-2: INTERGET
                        21 ** STEP 7: タイマ制御部
                        22 ** STEP 8: システムコールインタフェース
                        23 ** STEP 0-1: キューの初期化ルーチン(2/2)
                        24 
                        25 /* STEP 1: 初期化ルーチンの作成 */
                        26 ***************************************************************
                        27 **各種レジスタ定義
                        28 ***************************************************************
                        29 ***************
                        30 **レジスタ群の先頭
                        31 ***************
                        32 .equ REGBASE,   0xFFF000          | DMAPを使用．
                        33 .equ IOBASE,    0x00d00000
                        34 ***************
                        35 **割り込み関係のレジスタ
                        36 ***************
                        37 .equ IVR,       REGBASE+0x300     |割り込みベクタレジスタ
                        38 .equ IMR,       REGBASE+0x304     |割り込みマスクレジスタ
                        39 .equ ISR,       REGBASE+0x30c     |割り込みステータスレジスタ
                        40 .equ IPR,       REGBASE+0x310     |割り込みペンディングレジスタ
                        41 ***************
                        42 **タイマ関係のレジスタ
                        43 ***************
                        44 .equ TCTL1,     REGBASE+0x600     |タイマ１コントロールレジスタ
                        45 .equ TPRER1,    REGBASE+0x602     |タイマ１プリスケーラレジスタ
                        46 .equ TCMP1,     REGBASE+0x604     |タイマ１コンペアレジスタ
                        47 .equ TCN1,      REGBASE+0x608     |タイマ１カウンタレジスタ
                        48 .equ TSTAT1,    REGBASE+0x60a     |タイマ１ステータスレジスタ
                        49 ***************
                        50 ** UART1（送受信）関係のレジスタ
                        51 ***************
                        52 .equ USTCNT1,   REGBASE+0x900     | UART1ステータス/コントロールレジスタ
                        53 .equ UBAUD1,    REGBASE+0x902     | UART1ボーコントロールレジスタ
                        54 .equ URX1,      REGBASE+0x904     | UART1受信レジスタ
                        55 .equ UTX1,      REGBASE+0x906     | UART1送信レジスタ
                        56 ***************
                        57 ** LED
                        58 ***************
                        59 .equ LED7,      IOBASE+0x000002f  |ボード搭載のLED用レジスタ
                        60 .equ LED6,      IOBASE+0x000002d  |使用法については付録A.4.3.1
                        61 .equ LED5,      IOBASE+0x000002b
                        62 .equ LED4,      IOBASE+0x0000029
                        63 .equ LED3,      IOBASE+0x000003f
                        64 .equ LED2,      IOBASE+0x000003d
                        65 .equ LED1,      IOBASE+0x000003b
                        66 .equ LED0,      IOBASE+0x0000039
                        67 
                        68 
                        69 ***************
                        70 **システムコール番号
                        71 ***************
                        72 .equ SYSCALL_NUM_GETSTRING,     1
                        73 .equ SYSCALL_NUM_PUTSTRING,     2
                        74 .equ SYSCALL_NUM_RESET_TIMER,   3
                        75 .equ SYSCALL_NUM_SET_TIMER,     4
                        76 
                        77 
                        78 ***************************************************************
                        79 **スタック領域の確保
                        80 ***************************************************************
                        81 .section .bss
                        82 .even
                        83 SYS_STK:
000a40 0000 0000        84 	.ds.b   0x4000  |システムスタック領域
       0000 0000        84 
       0000 0000        84 
       0000 0000        84 
       0000 0000        84 
                        85 	.even
                        86 SYS_STK_TOP:        |システムスタック領域の最後尾
                        87 task_p:
004a40 0000 0000        88 	.ds.l 1         |タイマ用
                        89 
                        90 ***************************************************************
                        91 **初期化**内部デバイスレジスタには特定の値が設定されている．
                        92 **その理由を知るには，付録Bにある各レジスタの仕様を参照すること．
                        93 ***************************************************************
                        94 .section .text
                        95 .even
                        96 boot:
                        97 	*スーパーバイザ&各種設定を行っている最中の割込禁止
000400 46FC 2700        98 	move.w #0x2700,%SR
000404 4FF9 0000        99 	lea.l  SYS_STK_TOP, %SP | Set SSP
       0000             99 
                       100 
                       101 
                       102 	****************
                       103 	**割り込みコントローラの初期化
                       104 	****************
00040a 13FC 0040       105 	move.b #0x40, IVR       |ユーザ割り込みベクタ番号を
       00FF F300       105 
                       106 				| 0x40+levelに設定.
000412 23FC 00FF       107 	move.l #0x00ffffff, IMR  |全割り込みマスク|**割り込みを許可
       FFFF 00FF       107 
       F304            107 
                       108 
                       109 	****************
                       110 	**送受信(UART1)関係の初期化(割り込みレベルは4に固定されている)
                       111 	****************
00041c 33FC 0000       112 	move.w #0x0000, USTCNT1 |リセット
       00FF F900       112 
000424 33FC E10C       113 	move.w #0xE10C, USTCNT1 |送受信可能,パリティなし, 1 stop, 8 bit,
       00FF F900       113 
                       114 				|送受信割り込み禁止
00042c 33FC 0038       115 	move.w #0x0038, UBAUD1  | baud rate = 230400 bps
       00FF F902       115 
                       116 
                       117 	****************
                       118 	**タイマ関係の初期化(割り込みレベルは6に固定されている)
                       119 	*****************
000434 33FC 0004       120 	move.w #0x0004, TCTL1   | restart,割り込み不可,|システムクロックの1/16を単位と
       00FF F600       120 
                       121 	|タイマ使用停止
                       122 
                       123     *****************
                       124     ** キューの初期化
                       125     *****************
00043c 4EBA 00E0       126 	jsr INIT_Q
                       127 
                       128 	****************
                       129 	**割り込み処理ルーチンの初期化
                       130 	****************
000440 21FC 0000       131 	move.l #INTERFACE, 0x110			/* level 4, (64+4)*4 */ 
       0000 0110       131 
000448 21FC 0000       132 	move.l #timer_interface, 0x118		/* level 6, (64+6)*4 */
       0000 0118       132 
000450 21FC 0000       133 	move.l #SYSCALL_INTERFACE, 0x080	/* trap #0 割り込みベクタ設定 */
       0000 0080       133 
000458 23FC 00FF       134 	move.l #0x00ff3ff9, IMR				/* 割り込み許可*/
       3FF9 00FF       134 
       F304            134 
000462 46FC 2000       135 	move.w #0x2000,%SR					/* 走行レベルを0にする */
                       136 
000466 6000 0002       137 	bra MAIN
                       138 
                       139 	
                       140 ****************************************************************
                       141 ***プログラム領域
                       142 ****************************************************************
                       143 .section .text
                       144 .even
                       145 MAIN:
                       146 	**走行モードとレベルの設定(「ユーザモード」への移行処理)
00046a 46FC 0000       147 	move.w #0x0000, %SR  | USER MODE, LEVEL 0
00046e 4FF9 0000       148 	lea.l USR_STK_TOP,%SP  | user stackの設定
       0000            148 
                       149 	**システムコールによるRESET_TIMERの起動
000474 7003            150 	move.l #SYSCALL_NUM_RESET_TIMER,%D0
000476 4E40            151 	trap   #0
                       152 	**システムコールによるSET_TIMERの起動
000478 7004            153 	move.l #SYSCALL_NUM_SET_TIMER, %D0
00047a 323C C350       154 	move.w #50000, %D1
00047e 243C 0000       155 	move.l #TT,    %D2
       0000            155 
000484 4E40            156 	trap #0
                       157 	
                       158 ******************************
                       159 * sys_GETSTRING, sys_PUTSTRINGのテスト
                       160 *ターミナルの入力をエコーバックする
                       161 ******************************
                       162 LOOP:
000486 7001            163 	move.l #SYSCALL_NUM_GETSTRING, %D0
000488 7200            164 	move.l #0,   %D1        | ch    = 0
00048a 243C 0000       165 	move.l #BUF, %D2        | p    = #BUF
       0000            165 
000490 263C 0000       166 	move.l #256, %D3        | size = 256
       0100            166 
000496 4E40            167 	trap #0
000498 2600            168 	move.l %D0, %D3         | size = %D0 (length of given string)
00049a 7002            169 	move.l #SYSCALL_NUM_PUTSTRING, %D0
00049c 7200            170 	move.l #0,  %D1         | ch = 0
00049e 243C 0000       171 	move.l #BUF,%D2         | p  = #BUF
       0000            171 
0004a4 4E40            172 	trap #0
0004a6 6000 FFDE       173 	bra LOOP
                       174 
                       175 ******************************
                       176 *タイマのテスト
                       177 * ’******’を表示し改行する．
                       178 *５回実行すると，RESET_TIMERをする．
                       179 ******************************
                       180 TT:
0004aa 48E7 FFFE       181 	movem.l %D0-%D7/%A0-%A6,-(%SP)
0004ae 0C79 0005       182 	cmpi.w #5,TTC            | TTCカウンタで5回実行したかどうか数える
       0000 0000       182 
0004b6 6700 001C       183 	beq TTKILL               | 5回実行したら，タイマを止める
0004ba 7002            184 	move.l #SYSCALL_NUM_PUTSTRING,%D0
0004bc 7200            185 	move.l #0,    %D1        | ch = 0
0004be 243C 0000       186 	move.l #TMSG, %D2        | p  = #TMSG
       0000            186 
0004c4 7608            187 	move.l #8,    %D3        | size = 8
0004c6 4E40            188 	trap #0
0004c8 0679 0001       189 	addi.w #1,TTC            | TTCカウンタを1つ増やして
       0000 0000       189 
0004d0 6000 0006       190 	bra TTEND                |そのまま戻る
                       191 TTKILL:
0004d4 7003            192 	move.l #SYSCALL_NUM_RESET_TIMER,%D0
0004d6 4E40            193 	trap #0
                       194 TTEND:
0004d8 4CDF 7FFF       195 	movem.l (%SP)+,%D0-%D7/%A0-%A6
0004dc 4E75            196 	rts
                       197 
                       198 
                       199 ****************************************************************
                       200 ***初期値のあるデータ領域
                       201 ****************************************************************
                       202 .section .data
                       203 TMSG:
000814 2A2A 2A2A       204 	.ascii  "******\r\n"      | \r:行頭へ(キャリッジリターン)
       2A2A 0D0A       204 
                       205 	.even                     | \n:次の行へ(ラインフィード)
                       206 TTC:
00081c 0000            207 	.dc.w  0
                       208 	.even
                       209 
                       210 ****************************************************************
                       211 ***初期値の無いデータ領域
                       212 ****************************************************************
                       213 .section .bss
                       214 BUF:
004a44 0000 0000       215 	.ds.b 256           | BUF[256]
       0000 0000       215 
       0000 0000       215 
       0000 0000       215 
       0000 0000       215 
                       216 	.even
                       217 USR_STK:
004b44 0000 0000       218 	.ds.b 0x4000        |ユーザスタック領域
       0000 0000       218 
       0000 0000       218 
       0000 0000       218 
       0000 0000       218 
                       219 	.even
                       220 USR_STK_TOP:            |ユーザスタック領域の最後尾
                       221 
                       222 
                       223 .section .text
                       224 .even
                       225 
                       226 /* STEP 4-2: INTERUT INTERFACE, STEP 6-3: INTERGET INTERFACE */
                       227 ** ここから送受信割り込みインタフェース
                       228 ** 担当：齊藤
                       229 
                       230 ********************************
                       231 **送受信割り込みインターフェース
                       232 ********************************　
                       233 
                       234 ***************************************************************************************************
                       235 **【手順説明】
                       236 ** 受信レジスタ URX1 を %D3.W にコピー
                       237 ** %D3.W の下位 8bit(データ部分) を %D2.B にコピー
                       238 ** 今起こっている割り込みが，受信割り込みであるかを，%D3.W の 第 13 ビ
                       239 ** 受信割り込みであった場合，チャンネル ch = %D1.L =0, データ data = %D2.B と
                       240 ** 今起こっている 割り込みが，送信割り込みであるかを，送信レジスタ U
                       241 ** 送信割り込みであった場合，ch=%D1.L=0 として INTERPUT を呼び出す
                       242 ***************************************************************************************************
                       243 
                       244 ***************************************************************************************************
                       245 **【受信＆送信レジスタの説明】
                       246 ** UTX1 15bit 0:送信FIFOが空でない（INTERPUTで送信キューからOUTQ） 1:送信FIFOが
                       247 ** URX1 13bit 0:受信FIFOが空              				 1:受信FIFOにデータがある（INTERGETで
                       248 ***************************************************************************************************
                       249 
                       250 INTERFACE:
0004de 48E7 7080       251 	movem.l %d1-%d3/%a0, -(%sp)
                       252 INTERGET_INTERFACE:
0004e2 3639 00FF       253 	move.w  URX1, %d3	|URX1をd3にコピー
       F904            253 
0004e8 1403            254 	move.b  %d3, %d2    |d3の下位8bitをコピー 　data = %d2.b
0004ea 0243 2000       255 	andi.w  #0x2000,%d3	|13ビット目をチェック（bit13=1なら%d3が0x2000となる）
0004ee 0C43 2000       256 	cmpi.w  #0x2000,%d3	|%d3が0x2000であるかチェック
0004f2 6600 000C       257 	bne     INTERPUT_INTERFACE |13ビット目が１だったら受信割込
0004f6 7200            258 	move.l  #0, %d1 	|受信割り込みだったので、ch=%d1.l=0としてINTERGETを呼び出す
0004f8 4EBA 0228       259 	jsr     INTERGET        
0004fc 6000 001A       260 	bra	INTERFACE_FINISH
                       261 INTERPUT_INTERFACE:
000500 3639 00FF       262 	move.w  UTX1, %d3
       F906            262 
000506 0243 8000       263 	andi.w  #0x8000, %d3
00050a 0C43 0000       264 	cmpi.w  #0x0000, %d3 
00050e 6700 0008       265 	beq    INTERFACE_FINISH |UTX1 15bit = 0（送信FIFOが空でない）INTERPUT_FINISHへ
000512 7200            266 	move.l #0, %d1        	|送信割り込みだったので、ch=%d1.l=0としてINTERPUTを呼び
000514 4EBA 0126       267 	jsr    INTERPUT 
                       268 INTERFACE_FINISH:
000518 4CDF 010E       269 	movem.l (%sp)+, %d1-%d3/%a0
00051c 4E73            270 	rte
                       271 	
                       272 
                       273 /* STEP 0-1: キューの初期化ルーチン */
                       274 ** (2) 送信キュー・受信キューの両方について，キューのデータ用および
                       275 INIT_Q:	
00051e 48E7 00C0       276 	movem.l %a0-%a1 ,-(%sp)
                       277 
                       278 /* キュー0の初期化 */
000522 207C 0000       279 	movea.l	#Que0, %a0		/*構造体Que0の先頭アドレス*/
       0000            279 
000528 227C 0000       280 	move.l  #top, %a1	
       000A            280 
00052e D3C8            281 	add.l	%a0, %a1 		/*a1でキュー０の先頭番地を指定*/
000530 2149 0000       282 	move.l  %a1, out(%a0) 	/*enqueポインタ初期化*/
000534 2149 0004       283 	move.l  %a1, in(%a0) 	/*dequeポインタ初期化*/
000538 117C 0000       284 	move.b	#0, s(%a0) 		/*カウンタの初期化*/
       0008            284 
                       285 
                       286     /* キュー1の初期化 */
00053e 207C 0000       287 	movea.l #Que1, %a0 		/*構造体Que１の先頭アドレス*/
       0000            287 
000544 227C 0000       288 	move.l  #top, %a1
       000A            288 
00054a D3C8            289 	add.l   %a0, %a1 		/*a1でキュー1の先頭番地を指定*/
00054c 2149 0000       290 	move.l  %a1, out(%a0) 	/*enqueポインタ初期化*/
000550 2149 0004       291 	move.l  %a1, in(%a0) 	/*dequeポインタ初期化*/
000554 117C 0000       292 	move.b  #0, s(%a0) 		/*カウンタの初期化*/	
       0008            292 
                       293 
00055a 4CDF 0300       294 	movem.l (%sp)+, %a0-%a1
00055e 4E75            295 	rts
                       296 
                       297 
                       298 /* STEP 0-2: キューへの入力(INQ), 出力(OUTQ) ルーチンの作成 */
                       299 ** INQ(no, data)
                       300 ** argument:    (1) cue number no = %d0
                       301 **              (2) 8-bit data to write = %d1
                       302 ** return:      result flag = %d0 (0: failure, 1: success)
                       303 
                       304 /* (1) */
                       305 INQ:						/* キューへの入力 */
000560 40E7            306 	move.w	%sr, -(%sp)		/* (1) 現走行レベルの退避 */
000562 46FC 2700       307 	move.w	#0x2700, %sr	/* (2) 割り込み禁止 */
000566 48E7 00F0       308 	movem.l	%a0-%a3, -(%sp)	/* レジスタの退避 */
00056a 207C 0000       309 	movea.l	#Que0, %a0		/* キュー0参照用アドレス */
       0000            309 
000570 0C80 0000       310 	cmpi.l	#0, %d0	        /* キュー番号の確認 */
       0000            310 
000576 6700 0008       311 	beq	INQ_CHECK       	/*キュー1を使用*/
00057a 207C 0000       312 	movea.l	#Que1, %a0		/* キュー1参照用アドレス */
       0000            312 
                       313 /* (3) */
                       314 INQ_CHECK:
000580 0C68 0100       315 	cmpi.w	#256 ,s(%a0)	/* s == 256 ?：キュー内のデータの個数を確認 */
       0008            315 
000586 6600 0008       316 	bne	INQ_START			/* true:  キューが一杯でなければ書き込み可能 */
00058a 7000            317 	moveq.l	#0, %d0			/* false: (3-1) %D0 を0（失敗：queue full）に設定：書き込み失敗 
00058c 6000 0038       318 	bra	INQ_END             /* false: (3-2) (7)へ */
                       319 /* (4), (5-2) */
                       320 INQ_START:
                       321 /* (4) m[in] = data */
000590 2268 0004       322 	movea.l	in(%a0), %a1	/* 書き込み先アドレスを格納 */
000594 1281            323 	move.b	%d1, (%a1)		/* 書き込み処理 */
000596 2448            324 	movea.l	%a0, %a2
000598 D5FC 0000       325 	adda.l	#bottom, %a2	/* キューの末尾のアドレスを格納 */
       010A            325 
                       326 
                       327     /* (5) if (in == bottom) */
00059e B5E8 0004       328 	cmpa.l	in(%a0), %a2	/* 書き込んだ位置がキューの末尾か確認 */
0005a2 6700 000E       329 	beq	INQ_TOP
                       330 
                       331 	/* (5-2) else in++  */
0005a6 06A8 0000       332 	addi.l	#1, in(%a0)		/* 書き込み位置のアドレスを1加算 */
       0001 0004       332 
0005ae 6000 000E       333 	bra	INQ_SUCCESS
                       334 
                       335 /* (5-1) */
                       336 INQ_TOP:
                       337 /*  (5-1) in=top */
0005b2 267C 0000       338 	move.l	#top, %a3
       000A            338 
0005b8 D7C8            339 	add.l	%a0, %a3		/* topのアドレスを求める */
0005ba 214B 0004       340 	move.l	%a3, in(%a0)	/* 書き込み位置をキューの先頭に移動 */
                       341 /* (6) */
                       342 INQ_SUCCESS:
                       343 /* s++, %D0 を1（成功）に設定 */
0005be 0668 0001       344 	addi.w	#1, s(%a0)		/* 個数を1加算 */
       0008            344 
0005c4 7001            345 	moveq.l	#1, %d0			/* 書き込み成功 */
                       346 
                       347 /* (7) */
                       348 INQ_END:	
0005c6 4CDF 0F00       349 	movem.l	(%sp)+, %a0-%a3	/* レジスタの回復 */
0005ca 46DF            350 	move.w	(%sp)+, %sr		/* (7) 旧走行レベルの回復 */
0005cc 4E75            351 	rts
                       352 
                       353 **************************************************
                       354 ***a0:選択された構造体の先頭アドレス（変更不可）
                       355 ***a1:構造体の先頭アドレスのコピー（変更可
                       356 ***************************************************
                       357 
                       358 ** OUTQ(no, data)
                       359 ** argument:    cue number no = %d0
                       360 ** return:      (1) result flag = %d0 (0: failure, 1: success)
                       361 **              (2) 8-bit data to read = %d1
                       362 	
                       363 /* (1), (2) */	
                       364 OUTQ:
0005ce 40E7            365 	move.w	%sr, -(%sp) 	/* (1) 現走行レベルの退避 */
0005d0 46FC 2700       366 	move.w	#0x2700, %sr 	/* (2) 割り込み禁止 */
0005d4 48E7 00F0       367 	movem.l %a0-%a3, -(%sp) /* レジスタ退避 */
0005d8 207C 0000       368 	movea.l #Que0, %a0		/* キュー0参照用アドレス */
       0000            368 
                       369 
                       370     /* Que0 or Que1 */
0005de 0C80 0000       371 	cmpi.l	#0, %d0	        /* キュー番号の確認 */
       0000            371 
0005e4 6700 0008       372 	beq	OUTQ_CHECK      	/* キュー0を使用 */
                       373 	              			/* キュー1を使用 */
0005e8 207C 0000       374 	movea.l #Que1, %a0		/* キュー1参照用アドレス */
       0000            374 
                       375 /* (3) */	
                       376 OUTQ_CHECK:
                       377 /* (3) s == 0 ならば%D0 を0（失敗：queue empty）に設定し，(7) へ */
0005ee 0C68 0000       378 	cmpi.w	#0, s(%a0)      /* キュー内のデータの個数を確認 */
       0008            378 
0005f4 6600 0008       379 	bne	OUTQ_START      	/* キューが一杯でなければ読み出し可能 */
0005f8 7000            380 	moveq.l	 #0, %d0 		/*失敗*/
0005fa 6000 0038       381 	bra	OUTQ_END
                       382 /* (4), (5-2) */
                       383 OUTQ_START:
0005fe 2268 0000       384 	movea.l out(%a0), %a1   /* 読み出し先アドレスを格納*/
000602 1211            385 	move.b  (%a1), %d1      /* (4) data = m[out]；読み出し処理*/
000604 2448            386 	movea.l	%a0, %a2
000606 D5FC 0000       387 	adda.l	#bottom, %a2	/* キューの末尾のアドレスを格納 */
       010A            387 
                       388 
                       389     /* (5) if (out == bottom) */
00060c B5E8 0000       390 	cmpa.l	out(%a0), %a2	/* 読み込んだ位置がキューの末尾か確認 */
000610 6700 000E       391 	beq	OUTQ_TOP
                       392 
                       393 	/* (5-2) else out++  */
000614 06A8 0000       394 	addi.l	#1, out(%a0)	/* 読み出し位置のアドレスを1加算 */
       0001 0000       394 
00061c 6000 000E       395 	bra OUTQ_SUCCESS
                       396 
                       397 /* (5-1) */
                       398 OUTQ_TOP:	
                       399 /*  (5-1) out=top */
000620 267C 0000       400 	move.l	#top, %a3
       000A            400 
000626 D7C8            401 	add.l	%a0, %a3		/* topのアドレスを求める */
000628 214B 0000       402 	move.l	%a3, out(%a0)	/* 読み出し位置をキューの先頭に移動 */
                       403 
                       404 /* (6) */
                       405 OUTQ_SUCCESS:
                       406 /* s––, %D0 を1（成功）に設定 */
00062c 0468 0001       407 	subi.w	#1, s(%a0)		/* 個数を1減算 */
       0008            407 
000632 7001            408 	moveq.l	#1, %d0			/* 読み出し成功 */
                       409 
                       410 /* (7)  */
                       411 OUTQ_END:	
000634 4CDF 0F00       412 	movem.l	(%sp)+, %a0-%a3	/* レジスタの回復 */
000638 46DF            413 	move.w	(%sp)+, %sr		/* (7) 旧走行レベルの回復 */
00063a 4E75            414 	rts
                       415 
                       416 
                       417 **************************************************
                       418 ***a0:選択された構造体の先頭アドレス（変更不可）
                       419 ***a1:構造体の先頭アドレスのコピー（変更可）
                       420 ***************************************************
                       421 
                       422 **ここからINTERPUT・PUTSTRING
                       423 **担当：諸隈・宮田・瀬尾
                       424 
                       425 INTERPUT:
                       426     **(1) 割り込み禁止（走行レベルを7に設定）
00063c 46FC 2700       427     move.w  #0x2700, %SR
000640 48E7 8000       428     movem.l %d0, -(%sp)
                       429 	
                       430     **(2) ch ≠ 0 ならば、何もせずに復帰
000644 0C81 0000       431     cmp.l   #0, %d1
       0000            431 
00064a 6600 001C       432     bne     INTERPUT_Exit
                       433 
                       434     **(3) OUTQ(1, data) を実行する (= 送信キューから8bitデータを1つ取り出しdat
00064e 7001            435     move.l  #1, %d0     | キュー番号を指定 (1は送信キュー)
000650 4EBA FF7C       436     jsr     OUTQ
                       437 
                       438     **(4) OUTQの戻り値が0 (失敗) ならば、送信割り込みをマスク (USTCNT1を操
000654 0C80 0000       439     cmp.l  #0, %d0           | %D0にOUTQの戻り値が格納されている
       0000            439 
00065a 6700 0012       440     beq     INTERPUT_MUSK | OUTQが失敗した場合は何も送信せずに復帰
                       441 
                       442     **(5) dataを送信レジスタUTX1に代入して送信 (上位8ビット分のヘッダを忘
                       443     **上位8ビットのヘッダを付与しておく
00065e 0641 0800       444     add.w  #0x0800, %d1
000662 33C1 00FF       445     move.w  %d1, UTX1
       F906            445 
                       446     
                       447 INTERPUT_Exit:
                       448     **(6) 旧走行レベルの回復
000668 4CDF 0001       449     movem.l (%sp)+, %d0
00066c 4E75            450     rts
                       451 
                       452 INTERPUT_MUSK:
00066e 33FC E108       453     move.w #0xE108, USTCNT1
       00FF F900       453 
000676 6000 FFF0       454     bra INTERPUT_Exit
                       455 
                       456 /* STEP 5: 送信制御部の完成（PUTSTRING）*/
                       457 
                       458 *****************************************
                       459 *** a0=i
                       460 *** d0=sz(実際に送信したデータ数)
                       461 *** d1=ch
                       462 *** d2=p(データ読み込み先の先頭アドレス)
                       463 *** d3=size(送信するデータ数)
                       464 *****************************************
                       465 
                       466 PUTSTRING:
00067a 48E7 00F0       467     movem.l	%a0-%a3, -(%sp)  /* レジスタ退避 */
                       468 
                       469     ** (1) ch != 0 ならば，(11) へ．(=なにもせず復帰)
00067e 0C81 0000       470     cmp.l   #0, %d1          /* ch≠0ならば何もせず復帰 */
       0000            470 
000684 6600 004C       471     bne     PUTSTRING_END
                       472 	
                       473 	** (2) sz <- 0, i <- p
000688 41F9 0000       474 	lea.l	sz, %a0         /* sz <- 0 */
       0000            474 
00068e 43F9 0000       475 	lea.l	i, %a1          /*  i <- p */
       0000            475 
000694 20BC 0000       476     move.l	#0, (%a0)
       0000            476 
00069a 2282            477 	move.l	%d2, (%a1)
                       478 
                       479     ** (3) size = 0 ならば，(10)へ
00069c 0C83 0000       480 	cmp.l	#0, %d3
       0000            480 
0006a2 6700 002C       481 	beq	PUTSTRING_RETURN
                       482 
                       483 PUTSTRING_LOOP:
                       484     ** (4) sz = size ならば，(9)へ
0006a6 B690            485 	cmp.l	(%a0), %d3      /* sz = sizeならばUnmusk */
0006a8 6700 001E       486     beq	PUTSTRING_UNMUSK
                       487 	
                       488     ** (5) INQ(1, i) を実行し，送信キューへi番地のデータを書き込む．
0006ac 7001            489     move.l	#1, %d0         /* 送信キューを選択 */
0006ae 2651            490     movea.l	(%a1), %a3      /* 送信するデータを入力 */
0006b0 1213            491     move.b	(%a3), %d1      
0006b2 4EBA FEAC       492 	jsr	INQ	/*INQ(1, i)*/
                       493     
                       494     ** (6) INQ の復帰値が0 (失敗/ queue full) なら(9) へ
0006b6 0C80 0000       495     cmp.l	#0, %d0         /* INQの復帰値が0ならばUnmusk */
       0000            495 
0006bc 6700 000A       496     beq	PUTSTRING_UNMUSK
                       497 
                       498     ** (7) sz++, i++, (10) sz -> %d0
0006c0 5290            499     add.l	#1, (%a0)       /* sz++ */
0006c2 5291            500     add.l	#1, (%a1)       /* i++ */
                       501 
                       502     ** (8) (4)へ
0006c4 6000 FFE0       503     bra	PUTSTRING_LOOP
                       504 	
                       505 
                       506 PUTSTRING_UNMUSK:
                       507     ** (9) USTCNT1 を操作して送信割り込み許可(アンマスク)
0006c8 33FC E10C       508     move.w  #0xe10C, USTCNT1 /*送信割り込みをアンマスク*/
       00FF F900       508 
                       509 
                       510 PUTSTRING_RETURN:	
0006d0 2010            511 	move.l	(%a0), %d0	
                       512 
                       513 PUTSTRING_END:
0006d2 4CDF 0F00       514     movem.l	(%sp)+, %a0-%a3
0006d6 4E75            515     rts
                       516 
                       517 	
                       518 /* STEP 6: 受信制御部の完成（GETSTRING, INTERGET）*/
                       519 /* STEP 6-1: GETSTRING */
                       520 GETSTRING:
0006d8 48E7 7880       521     movem.l %d1-%d4/%a0, -(%sp)
                       522 
                       523 ** (1) ch!=0ならば，なにも実行せず復帰
0006dc 0C81 0000       524     cmpi.l #0x0, %d1
       0000            524 
0006e2 6600 002E       525     bne GETSTRING_Exit /* d1 != 0ならば，走行レベルを回復させ処理を終了 */
                       526 
                       527 ** (2) sz <- 0, i <- p
0006e6 7800            528     move.l #0, %d4
0006e8 2042            529     movea.l %d2, %a0
                       530 
                       531 GETSTRING_LOOP:
                       532 ** (3) sz = sizeならば，(9)へ
0006ea B684            533     cmp.l %d4, %d3
0006ec 6700 0024       534     beq GETSTRING_Exit
                       535 
                       536 ** (4) OUTQ(0, data)により，受信キューから8bitデータ読み込み
0006f0 7000            537     move.l #0, %d0
0006f2 4EBA FEDA       538     jsr OUTQ
                       539 
                       540 ** (5) OUTQの復帰値（%0の値）が0（＝失敗）なら(9)へ
0006f6 0C80 0000       541     cmp.l #0, %d0
       0000            541 
0006fc 6700 0014       542     beq GETSTRING_Exit
                       543 
                       544 ** (6) i番地にdataをコピー
000700 1081            545     move.b %d1, (%a0)
                       546 
                       547 ** (7) sz++, i++
000702 0684 0000       548     addi.l #1, %d4
       0001            548 
000708 D1FC 0000       549     adda.l #1, %a0
       0001            549 
                       550 
                       551 ** (8) (3)へ
00070e 6000 FFDA       552     bra GETSTRING_LOOP
                       553 
                       554 GETSTRING_Exit:
                       555 ** (9) sz -> %d0
000712 13FC 0038       556     move.b #'8',LED0
       00D0 0039       556 
00071a 2004            557     move.l %d4, %d0
00071c 4CDF 011E       558     movem.l (%sp)+, %d1-%d4/%a0
000720 4E75            559     rts
                       560 
                       561 /* STEP 6-2: INTERGET */
                       562 ***********************************************
                       563 *** INTERGET(ch, data)
                       564 *** 【機能】
                       565 *** - 受信データを受信キューに格納する
                       566 *** - チャネルchが0以外の場合は，なにも実行しない
                       567 *** 【入力】
                       568 *** - チャネル：ch -> %d1.l
                       569 *** - 受信データ：data -> %d2.b
                       570 *** 【戻り値】
                       571 *** なし
                       572 *** 【処理内容】
                       573 *** (1) ch!=0ならば，なにも実行せず復帰
                       574 *** (2) INQ(0, data)
                       575 ***********************************************
                       576 
                       577 INTERGET:
000722 48E7 E000       578     movem.l %d0-%d2, -(%sp)
                       579 
                       580 * (1) ch!=0ならば，なにも実行せず復帰
000726 0C81 0000       581     cmpi.l #0x0, %d1
       0000            581 
00072c 6600 001A       582     bne INTERGET_Finish  /* 走行レベルを回復させ処理を終了 */
                       583 
                       584 * (2) INQ(0, data)
000730 7000            585     move.l #0, %d0
000732 1202            586     move.b %d2, %d1
000734 13FC 0031       587     move.b #'1', LED2   /* 文字'1'をLEDの8桁目に表示 */
       00D0 003D       587 
00073c 4EBA FE22       588     jsr INQ
000740 13FC 0033       589     move.b #'3', LED3   /* 文字'3'をLEDの6桁目に表示 */
       00D0 003F       589 
                       590 
                       591 INTERGET_Finish:
000748 4CDF 0007       592     movem.l (%sp)+, %d0-%d2
00074c 4E75            593     rts
                       594 
                       595 /* STEP 7: タイマ制御部の完成（RESET_TIMER, SET_TIMER, CALL_RP, TIMER INTERFACE）*/
                       596 /* STEP 7-3: TIMER INTERFACE */
                       597 ** こっからTIMER関係
                       598 ** 担当：武石
                       599 timer_interface:
00074e 48E7 8000       600     movem.l %d0, -(%sp)         | レジスタ退避
000752 3039 00FF       601     move.w TSTAT1, %d0          | とりあえずd0 = TSTAT1 にコピー
       F60A            601 
000758 0240 0001       602     andi.w #0x0001, %d0         | d0 = d0 & 0x0001
00075c 6600 0004       603     bne timer_interface_label   | d0 = TSATA1 の第 0 ビットが 0 ならば timer_interface_lab
000760 4E73            604     rte                         | 1 ならば rte で復帰
                       605 
                       606 timer_interface_label:
000762 33FC 0000       607     move.w #0x0000, TSTAT1      | TSTAT1 = 0 (TSTAT1 のリセット)
       00FF F60A       607 
00076a 4EBA 0038       608     jsr CALL_RP                 | CALL RP を呼び出す
00076e 4CDF 0001       609     movem.l (%sp)+, %d0         | レジスタ回復
000772 4E73            610     rte
                       611 
                       612 /* STEP 7-1: RESET TIMER */
                       613 RESET_TIMER:
000774 33FC 0004       614     move.w #0x0004, TCTL1
       00FF F600       614 
00077c 4E75            615     rts
                       616 
                       617 /* STEP 7-2: SET TIMER */
                       618 SET_TIMER:
00077e 48E7 6000       619     movem.l	%d1-%d2, -(%sp)     | レジスタ退避
000782 23C2 0000       620     move.l %d2, task_p          | 先頭アドレス p → %D2.L を，大域変数 task p に代
       0000            620 
000788 33FC 00CE       621     move.w #0x00CE, TPRER1      | TPRER1の値は, 計算すると 206.2576 になった. 推奨値
       00FF F602       621 
000790 33C1 00FF       622     move.w %d1, TCMP1           | タイマ割り込み発生周期 t を，タイマ 1 コンペ
       F604            622 
000796 33FC 0015       623     move.w #0x0015, TCTL1       | TCTL1 = 0000 0000 0001 0101
       00FF F600       623 
00079e 4CDF 0006       624     movem.l	(%sp)+, %d1-%d2     | レジスタ復帰
0007a2 4E75            625     rts
                       626 
                       627 /* STEP 7-3: CALL_RP */
                       628 CALL_RP:
0007a4 48E7 0080       629     movem.l	%a0, -(%sp)
0007a8 2079 0000       630 	movea.l task_p, %a0 
       0000            630 
0007ae 4E90            631 	jsr (%a0)
0007b0 4CDF 0100       632 	movem.l (%sp)+, %a0
0007b4 4E75            633 	rts
                       634 
                       635 
                       636 /* STEP 8: システムコールインタフェースの完成 */
                       637 ** ここからシステムコールインタフェース
                       638 ** 担当：後藤
                       639 
                       640 SYSCALL_INTERFACE:
                       641 ** (1) システムコール番号 %D0 を 実行先アドレスに変換する．
                       642 ** (2) システムコールを呼び出す
                       643 
0007b6 48E7 0080       644     movem.l %a0, -(%sp) |レジスタ退避
0007ba 0C80 0000       645     cmp.l #SYSCALL_NUM_GETSTRING, %d0
       0001            645 
0007c0 6700 0020       646     beq SYSCALL_1
0007c4 0C80 0000       647     cmp.l #SYSCALL_NUM_PUTSTRING, %d0
       0002            647 
0007ca 6700 0020       648     beq SYSCALL_2
0007ce 0C80 0000       649     cmp.l #SYSCALL_NUM_RESET_TIMER, %d0
       0003            649 
0007d4 6700 0020       650     beq SYSCALL_3
0007d8 0C80 0000       651     cmp.l #SYSCALL_NUM_SET_TIMER, %d0
       0004            651 
0007de 6700 0020       652     beq SYSCALL_4
                       653 SYSCALL_1:
0007e2 203C 0000       654     move.l #GETSTRING, %d0
       0000            654 
0007e8 6000 0020       655     bra JUMP_SYSCALL
                       656 SYSCALL_2:
0007ec 203C 0000       657     move.l #PUTSTRING, %d0
       0000            657 
0007f2 6000 0016       658     bra JUMP_SYSCALL
                       659 SYSCALL_3:
0007f6 203C 0000       660     move.l #RESET_TIMER, %d0
       0000            660 
0007fc 6000 000C       661     bra JUMP_SYSCALL
                       662 SYSCALL_4:
000800 203C 0000       663     move.l #SET_TIMER, %d0
       0000            663 
000806 6000 0002       664     bra JUMP_SYSCALL
                       665 JUMP_SYSCALL:
00080a 2040            666     movea.l %d0, %a0
00080c 4E90            667     jsr (%a0)
                       668 SYSCALL_INTERFACE_FINISH:
00080e 4CDF 0100       669     movem.l (%sp)+,%a0  |レジスタ復帰
000812 4E73            670     rte
                       671 
                       672     
                       673 .section .data
                       674 
                       675 /* STEP 0-1: キューの初期化ルーチン */
                       676 ** (2) データ領域のアドレス（先頭・末尾）を代入，データ数の初期化
00081e 0000 0000       677 Que_START:	.ds.b	536
       0000 0000       677 
       0000 0000       677 
       0000 0000       677 
       0000 0000       677 
                       678 
                       679 	/*キューの各先頭アドレス*/
                       680     .equ    Que0, Que_START
                       681     .equ    Que1, Que0 + 0x0000010c
                       682 	
                       683 	/*キューの各要素のオフセット*/
                       684 	.equ	out, 0
                       685 	.equ	in, 4
                       686 	.equ	s, 8  /*2byte分確保*/
                       687 	.equ	top, 10
                       688 	.equ	bottom, 266
                       689 
000a36 0000 0000       690 sz:		.ds.l 1
000a3a 0000 0000       691 i: 		.ds.l 1
                       692 .end
