

   1               	        .data
   2               	        .align 2
   3               	environ:
   4 0000 0000 0000 	        .long 0
   5               	 	.align	2
   6               	
   7               	.extern main
   8               	.extern exit
   9               	.extern monitor_begin
  10               	.extern hardware_init_hook
  11               	.extern software_init_hook
  12               	.extern atexit
  13               	.extern __do_global_dtors
  14               	.extern __bss_start
  15               	.extern _end
  16               	
  17               	.global start
  18               	
  19               	.text
  20               	.even
  21               		/* See if user supplied their own stack (__stack != 0).  If not, then
  22               		 * default to using the value of %sp as set by the ROM monitor.
  23               		 */
  24 0000 207C 0000 		movel	#__stack, %a0
  24      0000 
  25 0006 B1FC 0000 		cmpl	#0, %a0
  25      0000 
  26 000c 6702      		jbeq    1f
  27 000e 2E48      		movel	%a0, %sp
  28               	1:
  29               		/* set up initial stack frame */
  30 0010 4E56 FFF8 		link	%a6, #-8
  31               	
  32               		/* zero out the bss section */
  33 0014 223C 0000 		movel	#__bss_start, %d1
  33      0000 
  34 001a 203C 0000 		movel	#_end, %d0
  34      0000 
  35 0020 B280      		cmpl	%d0, %d1
  36 0022 6712      		jbeq	3f
  37 0024 2041      		movl	%d1, %a0
  38 0026 9081      		subl	%d1, %d0
  39 0028 5380      		subql	#1, %d0
  40               	2:
  41 002a 4218      		clrb	(%a0)+
  42 002c 51C8 FFFC 		dbra	%d0, 2b
  43 0030 4240      		clrw	%d0
  44 0032 5380      		subql	#1, %d0
  45 0034 64F4      		jbcc	2b
  46               	3:
  47               		/* jmp monitor initialize after making up  bss */
  48 0036 4EF9 0000 		jmp	monitor_begin
  48      0000 
  49               	start:
  50               		/* monitor returns here.
  51               		 * re-setup stack for C programs.
  52               	         * See if user supplied their own stack (__stack != 0).  If not, then


  53               		 * default to using the value of %sp as set by the ROM monitor.
  54               		 */
  55 003c 207C 0000 		movel	#__stack, %a0
  55      0000 
  56 0042 B1FC 0000 		cmpl	#0, %a0
  56      0000 
  57 0048 6702      		jbeq    skip
  58 004a 2E48      		movel	%a0, %sp
  59               	skip:
  60               		/* set up initial stack frame */
  61 004c 4E56 FFF8 		link	%a6, #-8
  62               	
  63               		/*
  64               		 * initialize target specific stuff. Only execute these
  65               		 * functions it they exist.
  66               		 */
  67 0050 41F9 0000 		lea	hardware_init_hook, %a0
  67      0000 
  68 0056 B1FC 0000 		cmpl	#0, %a0
  68      0000 
  69 005c 6702      		jbeq	4f
  70 005e 4E90      		jsr     (%a0)
  71               	4:
  72 0060 41F9 0000 		lea	software_init_hook, %a0
  72      0000 
  73 0066 B1FC 0000 		cmpl	#0, %a0
  73      0000 
  74 006c 6702      		jbeq	5f
  75 006e 4E90      		jsr     (%a0)
  76               	5:
  77               	
  78               		/*
  79               		 * call the main routine from the application to get it going.
  80               		 * main (argc, argv, environ)
  81               		 * we pass argv as a pointer to NULL.
  82               		 */
  83               	
  84               		/* put __do_global_dtors in the atexit list so 
  85               		 * the destructors get run */
  86               	/* 
  87               		movel	#__do_global_dtors,(%sp)
  88               		jsr	atexit
  89               		movel	#__FINI_SECTION__,(%sp)
  90               		jsr	atexit
  91               		jsr	__INIT_SECTION__
  92               	*/
  93               		
  94               		** setup argv, argc and jump into main
  95 0070 4878 0000 	        pea     0
  96 0074 4879 0000 	        pea     environ
  96      0000 
  97 007a 486F 0004 	        pea     %sp@(4)
  98 007e 4878 0000 	        pea     0
  99 0082 4EB9 0000 		jsr	main
  99      0000 
 100 0088 2F00      		movel	%d0, %sp@-
 101               	


 102 008a 4EB9 0000 	        jsr     exit
 102      0000 
 103               	.even




   1               	** EECS-Exp II/III software-exp-I
   2               	** v1.0 / 2023-11-15
   3               	** Group 4
   4               	** 1TE21022R Seo Ichika, 	1TE21143S Miyata Yusaku, 	1TE21940P Saitoh Koshi
   5               	** 1TE21913T Takeishi Kota,	1TE21033K Goto Aoto,		1TE21057R Morokuma Haruto
   6               	
   7               	** INDEX
   8               	** STEP 1: 初期化ルーチン
   9               	** STEP 4-2: INTERUT INTERFACE
  10               	** STEP 6-3: INTERGET INTERFACE
  11               	** STEP 0-1: キューの初期化ルーチン(1/2)
  12               	** STEP 0-2: キューへの入力(INQ), 出力(OUTQ) ルーチン 
  13               	** STEP 4-1: INTERPUT
  14               	** STEP 5-1: PUTSTRING
  15               	** STEP 6-1: GETSTRING
  16               	** STEP 6-2: INTERGET
  17               	** STEP 7: タイマ制御部
  18               	** STEP 8: システムコールインタフェース
  19               	** STEP 0-1: キューの初期化ルーチン(2/2)
  20               	
  21               	/* STEP 1: 初期化ルーチンの作成 */
  22               	***************************************************************
  23               	**各種レジスタ定義
  24               	***************************************************************
  25               	***************
  26               	**レジスタ群の先頭
  27               	***************
  28               	.equ REGBASE,   0xFFF000          | DMAPを使用．
  29               	.equ IOBASE,    0x00d00000
  30               	***************
  31               	**割り込み関係のレジスタ
  32               	***************
  33               	.equ IVR,       REGBASE+0x300     |割り込みベクタレジスタ
  34               	.equ IMR,       REGBASE+0x304     |割り込みマスクレジスタ
  35               	.equ ISR,       REGBASE+0x30c     |割り込みステータスレジスタ
  36               	.equ IPR,       REGBASE+0x310     |割り込みペンディングレジスタ
  37               	***************
  38               	**タイマ関係のレジスタ
  39               	***************
  40               	.equ TCTL1,     REGBASE+0x600     |タイマ１コントロールレジスタ
  41               	.equ TPRER1,    REGBASE+0x602     |タイマ１プリスケーラレジスタ
  42               	.equ TCMP1,     REGBASE+0x604     |タイマ１コンペアレジスタ
  43               	.equ TCN1,      REGBASE+0x608     |タイマ１カウンタレジスタ
  44               	.equ TSTAT1,    REGBASE+0x60a     |タイマ１ステータスレジスタ
  45               	***************
  46               	** UART1（送受信）関係のレジスタ
  47               	***************
  48               	.equ USTCNT1,   REGBASE+0x900     | UART1ステータス/コントロールレジスタ
  49               	.equ UBAUD1,    REGBASE+0x902     | UART1ボーコントロールレジスタ
  50               	.equ URX1,      REGBASE+0x904     | UART1受信レジスタ
  51               	.equ UTX1,      REGBASE+0x906     | UART1送信レジスタ
  52               	***************
  53               	** LED
  54               	***************
  55               	.equ LED7,      IOBASE+0x000002f  |ボード搭載のLED用レジスタ
  56               	.equ LED6,      IOBASE+0x000002d  |使用法については付録A.4.3.1
  57               	.equ LED5,      IOBASE+0x000002b


  58               	.equ LED4,      IOBASE+0x0000029
  59               	.equ LED3,      IOBASE+0x000003f
  60               	.equ LED2,      IOBASE+0x000003d
  61               	.equ LED1,      IOBASE+0x000003b
  62               	.equ LED0,      IOBASE+0x0000039
  63               	
  64               	
  65               	***************
  66               	**システムコール番号
  67               	***************
  68               	.equ SYSCALL_NUM_GETSTRING,     1
  69               	.equ SYSCALL_NUM_PUTSTRING,     2
  70               	.equ SYSCALL_NUM_RESET_TIMER,   3
  71               	.equ SYSCALL_NUM_SET_TIMER,     4
  72               	
  73               	
  74               	***************************************************************
  75               	**スタック領域の確保
  76               	***************************************************************
  77               	.section .bss
  78               	.even
  79               	SYS_STK:
  80 0000 0000 0000 		.ds.b   0x4000  |システムスタック領域
  80      0000 0000 
  80      0000 0000 
  80      0000 0000 
  80      0000 0000 
  81               		.even
  82               	SYS_STK_TOP:        |システムスタック領域の最後尾
  83               	task_p:
  84 4000 0000 0000 		.ds.l 1         |タイマ用
  85               	
  86               	***************************************************************
  87               	**初期化**内部デバイスレジスタには特定の値が設定されている．
  88               	**その理由を知るには，付録Bにある各レジスタの仕様を参照すること．
  89               	***************************************************************
  90               	.section .text
  91               	.even
  92               	.extern start
  93               	.global monitor_begin
  94               	monitor_begin:
  95               	boot:
  96               		*スーパーバイザ&各種設定を行っている最中の割込禁止
  97 0000 46FC 2700 		move.w #0x2700,%SR
  98 0004 4FF9 0000 		lea.l  SYS_STK_TOP, %SP | Set SSP
  98      0000 
  99               	
 100               	
 101               		****************
 102               		**割り込みコントローラの初期化
 103               		****************
 104 000a 13FC 0040 		move.b #0x40, IVR       |ユーザ割り込みベクタ番号を
 104      00FF F300 
 105               					| 0x40+levelに設定.
 106 0012 23FC 00FF 		move.l #0x00ffffff, IMR  |全割り込みマスク|**割り込みを許可
 106      FFFF 00FF 
 106      F304 


 107               	
 108               		****************
 109               		**送受信(UART1)関係の初期化(割り込みレベルは4に固定されている)
 110               		****************
 111 001c 33FC 0000 		move.w #0x0000, USTCNT1 |リセット
 111      00FF F900 
 112 0024 33FC E10C 		move.w #0xE10C, USTCNT1 |送受信可能,パリティなし, 1 stop, 8 bit,
 112      00FF F900 
 113               					|送受信割り込み禁止
 114 002c 33FC 0038 		move.w #0x0038, UBAUD1  | baud rate = 230400 bps
 114      00FF F902 
 115               	
 116               		****************
 117               		**タイマ関係の初期化(割り込みレベルは6に固定されている)
 118               		*****************
 119 0034 33FC 0004 		move.w #0x0004, TCTL1   | restart,割り込み不可,|システムクロックの1/16を単位と
 119      00FF F600 
 120               		|タイマ使用停止
 121               	
 122               	    *****************
 123               	    ** キューの初期化
 124               	    *****************
 125 003c 4EBA 00E6 		jsr INIT_Q
 126               	
 127               		****************
 128               		**割り込み処理ルーチンの初期化
 129               		****************
 130 0040 21FC 0000 		move.l #INTERFACE, 0x110			/* level 4, (64+4)*4 */ 
 130      0000 0110 
 131 0048 21FC 0000 		move.l #timer_interface, 0x118		/* level 6, (64+6)*4 */
 131      0000 0118 
 132 0050 21FC 0000 		move.l #SYSCALL_INTERFACE, 0x080	/* trap #0 割り込みベクタ設定 */
 132      0000 0080 
 133 0058 23FC 00FF 		move.l #0x00ff3ff9, IMR				/* 割り込み許可*/
 133      3FF9 00FF 
 133      F304 
 134 0062 46FC 2000 		move.w #0x2000,%SR					/* 走行レベルを0にする */
 135               	
 136 0066 4EF9 0000 		jmp start
 136      0000 
 137 006c 6000 0002 		bra MAIN
 138               	
 139               		
 140               	****************************************************************
 141               	***プログラム領域
 142               	****************************************************************
 143               	.section .text
 144               	.even
 145               	MAIN:
 146               		**走行モードとレベルの設定(「ユーザモード」への移行処理)
 147 0070 46FC 0000 		move.w #0x0000, %SR  | USER MODE, LEVEL 0
 148 0074 4FF9 0000 		lea.l USR_STK_TOP,%SP  | user stackの設定
 148      0000 
 149               		**システムコールによるRESET_TIMERの起動
 150 007a 7003      		move.l #SYSCALL_NUM_RESET_TIMER,%D0
 151 007c 4E40      		trap   #0
 152               		**システムコールによるSET_TIMERの起動


 153 007e 7004      		move.l #SYSCALL_NUM_SET_TIMER, %D0
 154 0080 323C C350 		move.w #50000, %D1
 155 0084 243C 0000 		move.l #TT,    %D2
 155      0000 
 156 008a 4E40      		trap #0
 157               		
 158               	******************************
 159               	* sys_GETSTRING, sys_PUTSTRINGのテスト
 160               	*ターミナルの入力をエコーバックする
 161               	******************************
 162               	LOOP:
 163 008c 7001      		move.l #SYSCALL_NUM_GETSTRING, %D0
 164 008e 7200      		move.l #0,   %D1        | ch    = 0
 165 0090 243C 0000 		move.l #BUF, %D2        | p    = #BUF
 165      0000 
 166 0096 263C 0000 		move.l #256, %D3        | size = 256
 166      0100 
 167 009c 4E40      		trap #0
 168 009e 2600      		move.l %D0, %D3         | size = %D0 (length of given string)
 169 00a0 7002      		move.l #SYSCALL_NUM_PUTSTRING, %D0
 170 00a2 7200      		move.l #0,  %D1         | ch = 0
 171 00a4 243C 0000 		move.l #BUF,%D2         | p  = #BUF
 171      0000 
 172 00aa 4E40      		trap #0
 173 00ac 6000 FFDE 		bra LOOP
 174               	
 175               	******************************
 176               	*タイマのテスト
 177               	* ’******’を表示し改行する．
 178               	*５回実行すると，RESET_TIMERをする．
 179               	******************************
 180               	TT:
 181 00b0 48E7 FFFE 		movem.l %D0-%D7/%A0-%A6,-(%SP)
 182 00b4 0C79 0005 		cmpi.w #5,TTC            | TTCカウンタで5回実行したかどうか数える
 182      0000 0000 
 183 00bc 6700 001C 		beq TTKILL               | 5回実行したら，タイマを止める
 184 00c0 7002      		move.l #SYSCALL_NUM_PUTSTRING,%D0
 185 00c2 7200      		move.l #0,    %D1        | ch = 0
 186 00c4 243C 0000 		move.l #TMSG, %D2        | p  = #TMSG
 186      0000 
 187 00ca 7608      		move.l #8,    %D3        | size = 8
 188 00cc 4E40      		trap #0
 189 00ce 0679 0001 		addi.w #1,TTC            | TTCカウンタを1つ増やして
 189      0000 0000 
 190 00d6 6000 0006 		bra TTEND                |そのまま戻る
 191               	TTKILL:
 192 00da 7003      		move.l #SYSCALL_NUM_RESET_TIMER,%D0
 193 00dc 4E40      		trap #0
 194               	TTEND:
 195 00de 4CDF 7FFF 		movem.l (%SP)+,%D0-%D7/%A0-%A6
 196 00e2 4E75      		rts
 197               	
 198               	
 199               	****************************************************************
 200               	***初期値のあるデータ領域
 201               	****************************************************************
 202               	.section .data


 203               	TMSG:
 204 0000 2A2A 2A2A 		.ascii  "******\r\n"      | \r:行頭へ(キャリッジリターン)
 204      2A2A 0D0A 
 205               		.even                     | \n:次の行へ(ラインフィード)
 206               	TTC:
 207 0008 0000      		.dc.w  0
 208               		.even
 209               	
 210               	****************************************************************
 211               	***初期値の無いデータ領域
 212               	****************************************************************
 213               	.section .bss
 214               	BUF:
 215 4004 0000 0000 		.ds.b 256           | BUF[256]
 215      0000 0000 
 215      0000 0000 
 215      0000 0000 
 215      0000 0000 
 216               		.even
 217               	USR_STK:
 218 4104 0000 0000 		.ds.b 0x4000        |ユーザスタック領域
 218      0000 0000 
 218      0000 0000 
 218      0000 0000 
 218      0000 0000 
 219               		.even
 220               	USR_STK_TOP:            |ユーザスタック領域の最後尾
 221               	
 222               	
 223               	.section .text
 224               	.even
 225               	
 226               	/* STEP 4-2: INTERUT INTERFACE, STEP 6-3: INTERGET INTERFACE */
 227               	** ここから送受信割り込みインタフェース
 228               	** 担当：齊藤
 229               	
 230               	********************************
 231               	**送受信割り込みインターフェース
 232               	********************************　
 233               	
 234               	***************************************************************************************************
 235               	**【手順説明】
 236               	** 受信レジスタ URX1 を %D3.W にコピー
 237               	** %D3.W の下位 8bit(データ部分) を %D2.B にコピー
 238               	** 今起こっている割り込みが，受信割り込みであるかを，%D3.W の 第 13 ビ
 239               	** 受信割り込みであった場合，チャンネル ch = %D1.L =0, データ data = %D2.B と
 240               	** 今起こっている 割り込みが，送信割り込みであるかを，送信レジスタ U
 241               	** 送信割り込みであった場合，ch=%D1.L=0 として INTERPUT を呼び出す
 242               	***************************************************************************************************
 243               	
 244               	***************************************************************************************************
 245               	**【受信＆送信レジスタの説明】
 246               	** UTX1 15bit 0:送信FIFOが空でない（INTERPUTで送信キューからOUTQ） 1:送信FIFOが
 247               	** URX1 13bit 0:受信FIFOが空              				 1:受信FIFOにデータがある（INTERGETで
 248               	***************************************************************************************************
 249               	
 250               	INTERFACE:


 251 00e4 48E7 7080 		movem.l %d1-%d3/%a0, -(%sp)
 252               	INTERGET_INTERFACE:
 253 00e8 3639 00FF 		move.w  URX1, %d3	|URX1をd3にコピー
 253      F904 
 254 00ee 1403      		move.b  %d3, %d2    |d3の下位8bitをコピー 　data = %d2.b
 255 00f0 0243 2000 		andi.w  #0x2000,%d3	|13ビット目をチェック（bit13=1なら%d3が0x2000となる）
 256 00f4 0C43 2000 		cmpi.w  #0x2000,%d3	|%d3が0x2000であるかチェック
 257 00f8 6600 000C 		bne     INTERPUT_INTERFACE |13ビット目が１だったら受信割込
 258 00fc 7200      		move.l  #0, %d1 	|受信割り込みだったので、ch=%d1.l=0としてINTERGETを呼び出す
 259 00fe 4EBA 0228 		jsr     INTERGET        
 260 0102 6000 001A 		bra	INTERFACE_FINISH
 261               	INTERPUT_INTERFACE:
 262 0106 3639 00FF 		move.w  UTX1, %d3
 262      F906 
 263 010c 0243 8000 		andi.w  #0x8000, %d3
 264 0110 0C43 0000 		cmpi.w  #0x0000, %d3 
 265 0114 6700 0008 		beq    INTERFACE_FINISH |UTX1 15bit = 0（送信FIFOが空でない）INTERPUT_FINISHへ
 266 0118 7200      		move.l #0, %d1        	|送信割り込みだったので、ch=%d1.l=0としてINTERPUTを呼び
 267 011a 4EBA 0126 		jsr    INTERPUT 
 268               	INTERFACE_FINISH:
 269 011e 4CDF 010E 		movem.l (%sp)+, %d1-%d3/%a0
 270 0122 4E73      		rte
 271               		
 272               	
 273               	/* STEP 0-1: キューの初期化ルーチン */
 274               	** (2) 送信キュー・受信キューの両方について，キューのデータ用および
 275               	INIT_Q:	
 276 0124 48E7 00C0 		movem.l %a0-%a1 ,-(%sp)
 277               	
 278               	/* キュー0の初期化 */
 279 0128 207C 0000 		movea.l	#Que0, %a0		/*構造体Que0の先頭アドレス*/
 279      0000 
 280 012e 227C 0000 		move.l  #top, %a1	
 280      000A 
 281 0134 D3C8      		add.l	%a0, %a1 		/*a1でキュー０の先頭番地を指定*/
 282 0136 2149 0000 		move.l  %a1, out(%a0) 	/*enqueポインタ初期化*/
 283 013a 2149 0004 		move.l  %a1, in(%a0) 	/*dequeポインタ初期化*/
 284 013e 117C 0000 		move.b	#0, s(%a0) 		/*カウンタの初期化*/
 284      0008 
 285               	
 286               	    /* キュー1の初期化 */
 287 0144 207C 0000 		movea.l #Que1, %a0 		/*構造体Que１の先頭アドレス*/
 287      0000 
 288 014a 227C 0000 		move.l  #top, %a1
 288      000A 
 289 0150 D3C8      		add.l   %a0, %a1 		/*a1でキュー1の先頭番地を指定*/
 290 0152 2149 0000 		move.l  %a1, out(%a0) 	/*enqueポインタ初期化*/
 291 0156 2149 0004 		move.l  %a1, in(%a0) 	/*dequeポインタ初期化*/
 292 015a 117C 0000 		move.b  #0, s(%a0) 		/*カウンタの初期化*/	
 292      0008 
 293               	
 294 0160 4CDF 0300 		movem.l (%sp)+, %a0-%a1
 295 0164 4E75      		rts
 296               	
 297               	
 298               	/* STEP 0-2: キューへの入力(INQ), 出力(OUTQ) ルーチンの作成 */
 299               	** INQ(no, data)


 300               	** argument:    (1) cue number no = %d0
 301               	**              (2) 8-bit data to write = %d1
 302               	** return:      result flag = %d0 (0: failure, 1: success)
 303               	
 304               	/* (1) */
 305               	INQ:						/* キューへの入力 */
 306 0166 40E7      		move.w	%sr, -(%sp)		/* (1) 現走行レベルの退避 */
 307 0168 46FC 2700 		move.w	#0x2700, %sr	/* (2) 割り込み禁止 */
 308 016c 48E7 00F0 		movem.l	%a0-%a3, -(%sp)	/* レジスタの退避 */
 309 0170 207C 0000 		movea.l	#Que0, %a0		/* キュー0参照用アドレス */
 309      0000 
 310 0176 0C80 0000 		cmpi.l	#0, %d0	        /* キュー番号の確認 */
 310      0000 
 311 017c 6700 0008 		beq	INQ_CHECK       	/*キュー1を使用*/
 312 0180 207C 0000 		movea.l	#Que1, %a0		/* キュー1参照用アドレス */
 312      0000 
 313               	/* (3) */
 314               	INQ_CHECK:
 315 0186 0C68 0100 		cmpi.w	#256 ,s(%a0)	/* s == 256 ?：キュー内のデータの個数を確認 */
 315      0008 
 316 018c 6600 0008 		bne	INQ_START			/* true:  キューが一杯でなければ書き込み可能 */
 317 0190 7000      		moveq.l	#0, %d0			/* false: (3-1) %D0 を0（失敗：queue full）に設定：書き込み失敗 
 318 0192 6000 0038 		bra	INQ_END             /* false: (3-2) (7)へ */
 319               	/* (4), (5-2) */
 320               	INQ_START:
 321               	/* (4) m[in] = data */
 322 0196 2268 0004 		movea.l	in(%a0), %a1	/* 書き込み先アドレスを格納 */
 323 019a 1281      		move.b	%d1, (%a1)		/* 書き込み処理 */
 324 019c 2448      		movea.l	%a0, %a2
 325 019e D5FC 0000 		adda.l	#bottom, %a2	/* キューの末尾のアドレスを格納 */
 325      010A 
 326               	
 327               	    /* (5) if (in == bottom) */
 328 01a4 B5E8 0004 		cmpa.l	in(%a0), %a2	/* 書き込んだ位置がキューの末尾か確認 */
 329 01a8 6700 000E 		beq	INQ_TOP
 330               	
 331               		/* (5-2) else in++  */
 332 01ac 06A8 0000 		addi.l	#1, in(%a0)		/* 書き込み位置のアドレスを1加算 */
 332      0001 0004 
 333 01b4 6000 000E 		bra	INQ_SUCCESS
 334               	
 335               	/* (5-1) */
 336               	INQ_TOP:
 337               	/*  (5-1) in=top */
 338 01b8 267C 0000 		move.l	#top, %a3
 338      000A 
 339 01be D7C8      		add.l	%a0, %a3		/* topのアドレスを求める */
 340 01c0 214B 0004 		move.l	%a3, in(%a0)	/* 書き込み位置をキューの先頭に移動 */
 341               	/* (6) */
 342               	INQ_SUCCESS:
 343               	/* s++, %D0 を1（成功）に設定 */
 344 01c4 0668 0001 		addi.w	#1, s(%a0)		/* 個数を1加算 */
 344      0008 
 345 01ca 7001      		moveq.l	#1, %d0			/* 書き込み成功 */
 346               	
 347               	/* (7) */
 348               	INQ_END:	


 349 01cc 4CDF 0F00 		movem.l	(%sp)+, %a0-%a3	/* レジスタの回復 */
 350 01d0 46DF      		move.w	(%sp)+, %sr		/* (7) 旧走行レベルの回復 */
 351 01d2 4E75      		rts
 352               	
 353               	**************************************************
 354               	***a0:選択された構造体の先頭アドレス（変更不可）
 355               	***a1:構造体の先頭アドレスのコピー（変更可
 356               	***************************************************
 357               	
 358               	** OUTQ(no, data)
 359               	** argument:    cue number no = %d0
 360               	** return:      (1) result flag = %d0 (0: failure, 1: success)
 361               	**              (2) 8-bit data to read = %d1
 362               		
 363               	/* (1), (2) */	
 364               	OUTQ:
 365 01d4 40E7      		move.w	%sr, -(%sp) 	/* (1) 現走行レベルの退避 */
 366 01d6 46FC 2700 		move.w	#0x2700, %sr 	/* (2) 割り込み禁止 */
 367 01da 48E7 00F0 		movem.l %a0-%a3, -(%sp) /* レジスタ退避 */
 368 01de 207C 0000 		movea.l #Que0, %a0		/* キュー0参照用アドレス */
 368      0000 
 369               	
 370               	    /* Que0 or Que1 */
 371 01e4 0C80 0000 		cmpi.l	#0, %d0	        /* キュー番号の確認 */
 371      0000 
 372 01ea 6700 0008 		beq	OUTQ_CHECK      	/* キュー0を使用 */
 373               		              			/* キュー1を使用 */
 374 01ee 207C 0000 		movea.l #Que1, %a0		/* キュー1参照用アドレス */
 374      0000 
 375               	/* (3) */	
 376               	OUTQ_CHECK:
 377               	/* (3) s == 0 ならば%D0 を0（失敗：queue empty）に設定し，(7) へ */
 378 01f4 0C68 0000 		cmpi.w	#0, s(%a0)      /* キュー内のデータの個数を確認 */
 378      0008 
 379 01fa 6600 0008 		bne	OUTQ_START      	/* キューが一杯でなければ読み出し可能 */
 380 01fe 7000      		moveq.l	 #0, %d0 		/*失敗*/
 381 0200 6000 0038 		bra	OUTQ_END
 382               	/* (4), (5-2) */
 383               	OUTQ_START:
 384 0204 2268 0000 		movea.l out(%a0), %a1   /* 読み出し先アドレスを格納*/
 385 0208 1211      		move.b  (%a1), %d1      /* (4) data = m[out]；読み出し処理*/
 386 020a 2448      		movea.l	%a0, %a2
 387 020c D5FC 0000 		adda.l	#bottom, %a2	/* キューの末尾のアドレスを格納 */
 387      010A 
 388               	
 389               	    /* (5) if (out == bottom) */
 390 0212 B5E8 0000 		cmpa.l	out(%a0), %a2	/* 読み込んだ位置がキューの末尾か確認 */
 391 0216 6700 000E 		beq	OUTQ_TOP
 392               	
 393               		/* (5-2) else out++  */
 394 021a 06A8 0000 		addi.l	#1, out(%a0)	/* 読み出し位置のアドレスを1加算 */
 394      0001 0000 
 395 0222 6000 000E 		bra OUTQ_SUCCESS
 396               	
 397               	/* (5-1) */
 398               	OUTQ_TOP:	
 399               	/*  (5-1) out=top */


 400 0226 267C 0000 		move.l	#top, %a3
 400      000A 
 401 022c D7C8      		add.l	%a0, %a3		/* topのアドレスを求める */
 402 022e 214B 0000 		move.l	%a3, out(%a0)	/* 読み出し位置をキューの先頭に移動 */
 403               	
 404               	/* (6) */
 405               	OUTQ_SUCCESS:
 406               	/* s––, %D0 を1（成功）に設定 */
 407 0232 0468 0001 		subi.w	#1, s(%a0)		/* 個数を1減算 */
 407      0008 
 408 0238 7001      		moveq.l	#1, %d0			/* 読み出し成功 */
 409               	
 410               	/* (7)  */
 411               	OUTQ_END:	
 412 023a 4CDF 0F00 		movem.l	(%sp)+, %a0-%a3	/* レジスタの回復 */
 413 023e 46DF      		move.w	(%sp)+, %sr		/* (7) 旧走行レベルの回復 */
 414 0240 4E75      		rts
 415               	
 416               	
 417               	**************************************************
 418               	***a0:選択された構造体の先頭アドレス（変更不可）
 419               	***a1:構造体の先頭アドレスのコピー（変更可）
 420               	***************************************************
 421               	
 422               	**ここからINTERPUT・PUTSTRING
 423               	**担当：諸隈・宮田・瀬尾
 424               	
 425               	INTERPUT:
 426               	    **(1) 割り込み禁止（走行レベルを7に設定）
 427 0242 46FC 2700 	    move.w  #0x2700, %SR
 428 0246 48E7 8000 	    movem.l %d0, -(%sp)
 429               		
 430               	    **(2) ch ≠ 0 ならば、何もせずに復帰
 431 024a 0C81 0000 	    cmp.l   #0, %d1
 431      0000 
 432 0250 6600 001C 	    bne     INTERPUT_Exit
 433               	
 434               	    **(3) OUTQ(1, data) を実行する (= 送信キューから8bitデータを1つ取り出しdat
 435 0254 7001      	    move.l  #1, %d0     | キュー番号を指定 (1は送信キュー)
 436 0256 4EBA FF7C 	    jsr     OUTQ
 437               	
 438               	    **(4) OUTQの戻り値が0 (失敗) ならば、送信割り込みをマスク (USTCNT1を操
 439 025a 0C80 0000 	    cmp.l  #0, %d0           | %D0にOUTQの戻り値が格納されている
 439      0000 
 440 0260 6700 0012 	    beq     INTERPUT_MUSK | OUTQが失敗した場合は何も送信せずに復帰
 441               	
 442               	    **(5) dataを送信レジスタUTX1に代入して送信 (上位8ビット分のヘッダを忘
 443               	    **上位8ビットのヘッダを付与しておく
 444 0264 0641 0800 	    add.w  #0x0800, %d1
 445 0268 33C1 00FF 	    move.w  %d1, UTX1
 445      F906 
 446               	    
 447               	INTERPUT_Exit:
 448               	    **(6) 旧走行レベルの回復
 449 026e 4CDF 0001 	    movem.l (%sp)+, %d0
 450 0272 4E75      	    rts
 451               	


 452               	INTERPUT_MUSK:
 453 0274 33FC E108 	    move.w #0xE108, USTCNT1
 453      00FF F900 
 454 027c 6000 FFF0 	    bra INTERPUT_Exit
 455               	
 456               	/* STEP 5: 送信制御部の完成（PUTSTRING）*/
 457               	
 458               	*****************************************
 459               	*** a0=i
 460               	*** d0=sz(実際に送信したデータ数)
 461               	*** d1=ch
 462               	*** d2=p(データ読み込み先の先頭アドレス)
 463               	*** d3=size(送信するデータ数)
 464               	*****************************************
 465               	
 466               	PUTSTRING:
 467 0280 48E7 00F0 	    movem.l	%a0-%a3, -(%sp)  /* レジスタ退避 */
 468               	
 469               	    ** (1) ch != 0 ならば，(11) へ．(=なにもせず復帰)
 470 0284 0C81 0000 	    cmp.l   #0, %d1          /* ch≠0ならば何もせず復帰 */
 470      0000 
 471 028a 6600 004C 	    bne     PUTSTRING_END
 472               		
 473               		** (2) sz <- 0, i <- p
 474 028e 41F9 0000 		lea.l	sz, %a0         /* sz <- 0 */
 474      0000 
 475 0294 43F9 0000 		lea.l	i, %a1          /*  i <- p */
 475      0000 
 476 029a 20BC 0000 	    move.l	#0, (%a0)
 476      0000 
 477 02a0 2282      		move.l	%d2, (%a1)
 478               	
 479               	    ** (3) size = 0 ならば，(10)へ
 480 02a2 0C83 0000 		cmp.l	#0, %d3
 480      0000 
 481 02a8 6700 002C 		beq	PUTSTRING_RETURN
 482               	
 483               	PUTSTRING_LOOP:
 484               	    ** (4) sz = size ならば，(9)へ
 485 02ac B690      		cmp.l	(%a0), %d3      /* sz = sizeならばUnmusk */
 486 02ae 6700 001E 	    beq	PUTSTRING_UNMUSK
 487               		
 488               	    ** (5) INQ(1, i) を実行し，送信キューへi番地のデータを書き込む．
 489 02b2 7001      	    move.l	#1, %d0         /* 送信キューを選択 */
 490 02b4 2651      	    movea.l	(%a1), %a3      /* 送信するデータを入力 */
 491 02b6 1213      	    move.b	(%a3), %d1      
 492 02b8 4EBA FEAC 		jsr	INQ	/*INQ(1, i)*/
 493               	    
 494               	    ** (6) INQ の復帰値が0 (失敗/ queue full) なら(9) へ
 495 02bc 0C80 0000 	    cmp.l	#0, %d0         /* INQの復帰値が0ならばUnmusk */
 495      0000 
 496 02c2 6700 000A 	    beq	PUTSTRING_UNMUSK
 497               	
 498               	    ** (7) sz++, i++, (10) sz -> %d0
 499 02c6 5290      	    add.l	#1, (%a0)       /* sz++ */
 500 02c8 5291      	    add.l	#1, (%a1)       /* i++ */
 501               	


 502               	    ** (8) (4)へ
 503 02ca 6000 FFE0 	    bra	PUTSTRING_LOOP
 504               		
 505               	
 506               	PUTSTRING_UNMUSK:
 507               	    ** (9) USTCNT1 を操作して送信割り込み許可(アンマスク)
 508 02ce 33FC E10C 	    move.w  #0xe10C, USTCNT1 /*送信割り込みをアンマスク*/
 508      00FF F900 
 509               	
 510               	PUTSTRING_RETURN:	
 511 02d6 2010      		move.l	(%a0), %d0	
 512               	
 513               	PUTSTRING_END:
 514 02d8 4CDF 0F00 	    movem.l	(%sp)+, %a0-%a3
 515 02dc 4E75      	    rts
 516               	
 517               		
 518               	/* STEP 6: 受信制御部の完成（GETSTRING, INTERGET）*/
 519               	/* STEP 6-1: GETSTRING */
 520               	GETSTRING:
 521 02de 48E7 7880 	    movem.l %d1-%d4/%a0, -(%sp)
 522               	
 523               	** (1) ch!=0ならば，なにも実行せず復帰
 524 02e2 0C81 0000 	    cmpi.l #0x0, %d1
 524      0000 
 525 02e8 6600 002E 	    bne GETSTRING_Exit /* d1 != 0ならば，走行レベルを回復させ処理を終了 */
 526               	
 527               	** (2) sz <- 0, i <- p
 528 02ec 7800      	    move.l #0, %d4
 529 02ee 2042      	    movea.l %d2, %a0
 530               	
 531               	GETSTRING_LOOP:
 532               	** (3) sz = sizeならば，(9)へ
 533 02f0 B684      	    cmp.l %d4, %d3
 534 02f2 6700 0024 	    beq GETSTRING_Exit
 535               	
 536               	** (4) OUTQ(0, data)により，受信キューから8bitデータ読み込み
 537 02f6 7000      	    move.l #0, %d0
 538 02f8 4EBA FEDA 	    jsr OUTQ
 539               	
 540               	** (5) OUTQの復帰値（%0の値）が0（＝失敗）なら(9)へ
 541 02fc 0C80 0000 	    cmp.l #0, %d0
 541      0000 
 542 0302 6700 0014 	    beq GETSTRING_Exit
 543               	
 544               	** (6) i番地にdataをコピー
 545 0306 1081      	    move.b %d1, (%a0)
 546               	
 547               	** (7) sz++, i++
 548 0308 0684 0000 	    addi.l #1, %d4
 548      0001 
 549 030e D1FC 0000 	    adda.l #1, %a0
 549      0001 
 550               	
 551               	** (8) (3)へ
 552 0314 6000 FFDA 	    bra GETSTRING_LOOP
 553               	


 554               	GETSTRING_Exit:
 555               	** (9) sz -> %d0
 556 0318 13FC 0038 	    move.b #'8',LED0
 556      00D0 0039 
 557 0320 2004      	    move.l %d4, %d0
 558 0322 4CDF 011E 	    movem.l (%sp)+, %d1-%d4/%a0
 559 0326 4E75      	    rts
 560               	
 561               	/* STEP 6-2: INTERGET */
 562               	***********************************************
 563               	*** INTERGET(ch, data)
 564               	*** 【機能】
 565               	*** - 受信データを受信キューに格納する
 566               	*** - チャネルchが0以外の場合は，なにも実行しない
 567               	*** 【入力】
 568               	*** - チャネル：ch -> %d1.l
 569               	*** - 受信データ：data -> %d2.b
 570               	*** 【戻り値】
 571               	*** なし
 572               	*** 【処理内容】
 573               	*** (1) ch!=0ならば，なにも実行せず復帰
 574               	*** (2) INQ(0, data)
 575               	***********************************************
 576               	
 577               	INTERGET:
 578 0328 48E7 E000 	    movem.l %d0-%d2, -(%sp)
 579               	
 580               	* (1) ch!=0ならば，なにも実行せず復帰
 581 032c 0C81 0000 	    cmpi.l #0x0, %d1
 581      0000 
 582 0332 6600 001A 	    bne INTERGET_Finish  /* 走行レベルを回復させ処理を終了 */
 583               	
 584               	* (2) INQ(0, data)
 585 0336 7000      	    move.l #0, %d0
 586 0338 1202      	    move.b %d2, %d1
 587 033a 13FC 0031 	    move.b #'1', LED2   /* 文字'1'をLEDの8桁目に表示 */
 587      00D0 003D 
 588 0342 4EBA FE22 	    jsr INQ
 589 0346 13FC 0033 	    move.b #'3', LED3   /* 文字'3'をLEDの6桁目に表示 */
 589      00D0 003F 
 590               	
 591               	INTERGET_Finish:
 592 034e 4CDF 0007 	    movem.l (%sp)+, %d0-%d2
 593 0352 4E75      	    rts
 594               	
 595               	/* STEP 7: タイマ制御部の完成（RESET_TIMER, SET_TIMER, CALL_RP, TIMER INTERFACE）*/
 596               	/* STEP 7-3: TIMER INTERFACE */
 597               	** こっからTIMER関係
 598               	** 担当：武石
 599               	timer_interface:
 600 0354 48E7 8000 	    movem.l %d0, -(%sp)         | レジスタ退避
 601 0358 3039 00FF 	    move.w TSTAT1, %d0          | とりあえずd0 = TSTAT1 にコピー
 601      F60A 
 602 035e 0240 0001 	    andi.w #0x0001, %d0         | d0 = d0 & 0x0001
 603 0362 6600 0004 	    bne timer_interface_label   | d0 = TSATA1 の第 0 ビットが 0 ならば timer_interface_lab
 604 0366 4E73      	    rte                         | 1 ならば rte で復帰
 605               	


 606               	timer_interface_label:
 607 0368 33FC 0000 	    move.w #0x0000, TSTAT1      | TSTAT1 = 0 (TSTAT1 のリセット)
 607      00FF F60A 
 608 0370 4EBA 0038 	    jsr CALL_RP                 | CALL RP を呼び出す
 609 0374 4CDF 0001 	    movem.l (%sp)+, %d0         | レジスタ回復
 610 0378 4E73      	    rte
 611               	
 612               	/* STEP 7-1: RESET TIMER */
 613               	RESET_TIMER:
 614 037a 33FC 0004 	    move.w #0x0004, TCTL1
 614      00FF F600 
 615 0382 4E75      	    rts
 616               	
 617               	/* STEP 7-2: SET TIMER */
 618               	SET_TIMER:
 619 0384 48E7 6000 	    movem.l	%d1-%d2, -(%sp)     | レジスタ退避
 620 0388 23C2 0000 	    move.l %d2, task_p          | 先頭アドレス p → %D2.L を，大域変数 task p に代
 620      0000 
 621 038e 33FC 00CE 	    move.w #0x00CE, TPRER1      | TPRER1の値は, 計算すると 206.2576 になった. 推奨値
 621      00FF F602 
 622 0396 33C1 00FF 	    move.w %d1, TCMP1           | タイマ割り込み発生周期 t を，タイマ 1 コンペ
 622      F604 
 623 039c 33FC 0015 	    move.w #0x0015, TCTL1       | TCTL1 = 0000 0000 0001 0101
 623      00FF F600 
 624 03a4 4CDF 0006 	    movem.l	(%sp)+, %d1-%d2     | レジスタ復帰
 625 03a8 4E75      	    rts
 626               	
 627               	/* STEP 7-3: CALL_RP */
 628               	CALL_RP:
 629 03aa 48E7 0080 	    movem.l	%a0, -(%sp)
 630 03ae 2079 0000 		movea.l task_p, %a0 
 630      0000 
 631 03b4 4E90      		jsr (%a0)
 632 03b6 4CDF 0100 		movem.l (%sp)+, %a0
 633 03ba 4E75      		rts
 634               	
 635               	
 636               	/* STEP 8: システムコールインタフェースの完成 */
 637               	** ここからシステムコールインタフェース
 638               	** 担当：後藤
 639               	
 640               	SYSCALL_INTERFACE:
 641               	** (1) システムコール番号 %D0 を 実行先アドレスに変換する．
 642               	** (2) システムコールを呼び出す
 643               	
 644 03bc 48E7 0080 	    movem.l %a0, -(%sp) |レジスタ退避
 645 03c0 0C80 0000 	    cmp.l #SYSCALL_NUM_GETSTRING, %d0
 645      0001 
 646 03c6 6700 0020 	    beq SYSCALL_1
 647 03ca 0C80 0000 	    cmp.l #SYSCALL_NUM_PUTSTRING, %d0
 647      0002 
 648 03d0 6700 0020 	    beq SYSCALL_2
 649 03d4 0C80 0000 	    cmp.l #SYSCALL_NUM_RESET_TIMER, %d0
 649      0003 
 650 03da 6700 0020 	    beq SYSCALL_3
 651 03de 0C80 0000 	    cmp.l #SYSCALL_NUM_SET_TIMER, %d0
 651      0004 


 652 03e4 6700 0020 	    beq SYSCALL_4
 653               	SYSCALL_1:
 654 03e8 203C 0000 	    move.l #GETSTRING, %d0
 654      0000 
 655 03ee 6000 0020 	    bra JUMP_SYSCALL
 656               	SYSCALL_2:
 657 03f2 203C 0000 	    move.l #PUTSTRING, %d0
 657      0000 
 658 03f8 6000 0016 	    bra JUMP_SYSCALL
 659               	SYSCALL_3:
 660 03fc 203C 0000 	    move.l #RESET_TIMER, %d0
 660      0000 
 661 0402 6000 000C 	    bra JUMP_SYSCALL
 662               	SYSCALL_4:
 663 0406 203C 0000 	    move.l #SET_TIMER, %d0
 663      0000 
 664 040c 6000 0002 	    bra JUMP_SYSCALL
 665               	JUMP_SYSCALL:
 666 0410 2040      	    movea.l %d0, %a0
 667 0412 4E90      	    jsr (%a0)
 668               	SYSCALL_INTERFACE_FINISH:
 669 0414 4CDF 0100 	    movem.l (%sp)+,%a0  |レジスタ復帰
 670 0418 4E73      	    rte
 671               	
 672               	    
 673               	.section .data
 674               	
 675               	/* STEP 0-1: キューの初期化ルーチン */
 676               	** (2) データ領域のアドレス（先頭・末尾）を代入，データ数の初期化
 677 000a 0000 0000 	Que_START:	.ds.b	536
 677      0000 0000 
 677      0000 0000 
 677      0000 0000 
 677      0000 0000 
 678               	
 679               		/*キューの各先頭アドレス*/
 680               	    .equ    Que0, Que_START
 681               	    .equ    Que1, Que0 + 0x0000010c
 682               		
 683               		/*キューの各要素のオフセット*/
 684               		.equ	out, 0
 685               		.equ	in, 4
 686               		.equ	s, 8  /*2byte分確保*/
 687               		.equ	top, 10
 688               		.equ	bottom, 266
 689               	
 690 0222 0000 0000 	sz:		.ds.l 1
 691 0226 0000 0000 	i: 		.ds.l 1
 692               	.end




   1               	.include "equdefs.inc"
   1               	***************************************************************
   2               	**各種レジスタ定義
   3               	***************************************************************
   4               	***************
   5               	**レジスタ群の先頭
   6               	***************
   7               	.equ REGBASE,   0xFFF000          | DMAPを使用．
   8               	.equ IOBASE,    0x00d00000
   9               	***************
  10               	**割り込み関係のレジスタ
  11               	***************
  12               	.equ IVR,       REGBASE+0x300     |割り込みベクタレジスタ
  13               	.equ IMR,       REGBASE+0x304     |割り込みマスクレジスタ
  14               	.equ ISR,       REGBASE+0x30c     |割り込みステータスレジスタ
  15               	.equ IPR,       REGBASE+0x310     |割り込みペンディングレジスタ
  16               	***************
  17               	**タイマ関係のレジスタ
  18               	***************
  19               	.equ TCTL1,     REGBASE+0x600     |タイマ１コントロールレジスタ
  20               	.equ TPRER1,    REGBASE+0x602     |タイマ１プリスケーラレジスタ
  21               	.equ TCMP1,     REGBASE+0x604     |タイマ１コンペアレジスタ
  22               	.equ TCN1,      REGBASE+0x608     |タイマ１カウンタレジスタ
  23               	.equ TSTAT1,    REGBASE+0x60a     |タイマ１ステータスレジスタ
  24               	***************
  25               	** UART1（送受信）関係のレジスタ
  26               	***************
  27               	.equ USTCNT1,   REGBASE+0x900     | UART1ステータス/コントロールレジスタ
  28               	.equ UBAUD1,    REGBASE+0x902     | UART1ボーコントロールレジスタ
  29               	.equ URX1,      REGBASE+0x904     | UART1受信レジスタ
  30               	.equ UTX1,      REGBASE+0x906     | UART1送信レジスタ
  31               	***************
  32               	** LED
  33               	***************
  34               	.equ LED7,      IOBASE+0x000002f  |ボード搭載のLED用レジスタ
  35               	.equ LED6,      IOBASE+0x000002d  |使用法については付録A.4.3.1
  36               	.equ LED5,      IOBASE+0x000002b
  37               	.equ LED4,      IOBASE+0x0000029
  38               	.equ LED3,      IOBASE+0x000003f
  39               	.equ LED2,      IOBASE+0x000003d
  40               	.equ LED1,      IOBASE+0x000003b
  41               	.equ LED0,      IOBASE+0x0000039
  42               	
  43               	***************
  44               	**システムコール番号
  45               	***************
  46               	.equ SYSCALL_NUM_GETSTRING,     1
  47               	.equ SYSCALL_NUM_PUTSTRING,     2
  48               	.equ SYSCALL_NUM_RESET_TIMER,   3
  49               	.equ SYSCALL_NUM_SET_TIMER,     4
   2               	.global inbyte
   3               	
   4               	.text
   5               	.even
   6               	
   7               	inbyte:
   8 0000 48E7 7080 		movem.l %a0/%d1-%d3, -(%SP)		/* STORE REGISTERS */


   9 0004 41F9 0000 		lea.l ibDATA, %a0				/* SET ADDRESS OF ibDATA TO a0 */
   9      0000 
  10               	inbyte_loop:
  11               		/* SYSCALL: GETSTRING */
  12 000a 7001      		move.l #SYSCALL_NUM_GETSTRING, %D0
  13 000c 7200      		move.l #0,  %d1         		| ch   = 0
  14 000e 2408      		move.l %a0, %d2         		| p    = #ibDATA
  15 0010 7601      		move.l #1, %d3          		| size = 1
  16 0012 4E40      		trap #0
  17               	
  18               		/* FLAG CHECK */
  19 0014 0C80 0000 		cmp.l #0, %d0					/* see if GETSTRING is successful */
  19      0000 
  20 001a 6700 FFEE 		beq inbyte_loop					/* if false, retry */
  21               	
  22               		/* SUCCESS */
  23 001e 1010      		move.b (%a0), %d0				/* copy retuned data to d0 */
  24 0020 13C0 00D0 		move.b %d0, LED7
  24      002F 
  25 0026 4CDF 010E 		movem.l (%SP)+, %a0/%d1-%d3		/* STORE REGISTERS */
  26 002a 4E75      		rts
  27               	        
  28               	.section .bss
  29               	.even
  30               	
  31               	.global DATA
  32               	ibDATA:
  33 0000 00        		.ds.b 1
  34 0001 00        		.even




   1               	.include "equdefs.inc"
   1               	***************************************************************
   2               	**各種レジスタ定義
   3               	***************************************************************
   4               	***************
   5               	**レジスタ群の先頭
   6               	***************
   7               	.equ REGBASE,   0xFFF000          | DMAPを使用．
   8               	.equ IOBASE,    0x00d00000
   9               	***************
  10               	**割り込み関係のレジスタ
  11               	***************
  12               	.equ IVR,       REGBASE+0x300     |割り込みベクタレジスタ
  13               	.equ IMR,       REGBASE+0x304     |割り込みマスクレジスタ
  14               	.equ ISR,       REGBASE+0x30c     |割り込みステータスレジスタ
  15               	.equ IPR,       REGBASE+0x310     |割り込みペンディングレジスタ
  16               	***************
  17               	**タイマ関係のレジスタ
  18               	***************
  19               	.equ TCTL1,     REGBASE+0x600     |タイマ１コントロールレジスタ
  20               	.equ TPRER1,    REGBASE+0x602     |タイマ１プリスケーラレジスタ
  21               	.equ TCMP1,     REGBASE+0x604     |タイマ１コンペアレジスタ
  22               	.equ TCN1,      REGBASE+0x608     |タイマ１カウンタレジスタ
  23               	.equ TSTAT1,    REGBASE+0x60a     |タイマ１ステータスレジスタ
  24               	***************
  25               	** UART1（送受信）関係のレジスタ
  26               	***************
  27               	.equ USTCNT1,   REGBASE+0x900     | UART1ステータス/コントロールレジスタ
  28               	.equ UBAUD1,    REGBASE+0x902     | UART1ボーコントロールレジスタ
  29               	.equ URX1,      REGBASE+0x904     | UART1受信レジスタ
  30               	.equ UTX1,      REGBASE+0x906     | UART1送信レジスタ
  31               	***************
  32               	** LED
  33               	***************
  34               	.equ LED7,      IOBASE+0x000002f  |ボード搭載のLED用レジスタ
  35               	.equ LED6,      IOBASE+0x000002d  |使用法については付録A.4.3.1
  36               	.equ LED5,      IOBASE+0x000002b
  37               	.equ LED4,      IOBASE+0x0000029
  38               	.equ LED3,      IOBASE+0x000003f
  39               	.equ LED2,      IOBASE+0x000003d
  40               	.equ LED1,      IOBASE+0x000003b
  41               	.equ LED0,      IOBASE+0x0000039
  42               	
  43               	***************
  44               	**システムコール番号
  45               	***************
  46               	.equ SYSCALL_NUM_GETSTRING,     1
  47               	.equ SYSCALL_NUM_PUTSTRING,     2
  48               	.equ SYSCALL_NUM_RESET_TIMER,   3
  49               	.equ SYSCALL_NUM_SET_TIMER,     4
   2               	.global outbyte
   3               	
   4               	.text
   5               	.even
   6               	
   7               	outbyte:
   8 0000 48E7 7040 		movem.l %d1-%d3/%a1, -(%SP)	/* STORE REGISTERS */


   9               	outbyte_loop:
  10               		/* OBTAIN ARGUMENTS TO DISPLAY */
  11               		/* By the stack storing above, */
  12               		/*     the values of 4 registers and PC re are stored */
  13               		/*     which means that, the value of stack pointer is decreased */
  14               		/* To execute GETSTRING, calculate the address where the actual data to display is stored */
  15               	
  16               		/* Add 3 bytes because the argument is stored begin sign-extended 4 bytes from 1 byte */
  17               		/* 23 [bytes] = 5 [registers] * 4 [bytes/register] + 3 [byte] */
  18               	
  19 0004 224F      		movea.l	%sp, %a1			/* copy head address of stack pointer */
  20 0006 7417      		move.l	#23,   %d2			/* calculate the necessary address number to obtain the argument */
  21 0008 D3C2      		adda.l	%d2,   %a1			/* by summing, go to the target to display */
  22               	
  23 000a 13D1 0000 		move.b	(%a1), obDATA		/* copy data to obDATA */
  23      0000 
  24 0010 13F9 0000 		move.b obDATA, LED6
  24      0000 00D0 
  24      002D 
  25               	
  26               		/* SYSCALL: PUTSTRING */
  27 001a 7002      		move.l #SYSCALL_NUM_PUTSTRING, %D0
  28 001c 7200      		move.l #0,  %D1         	| ch = 0
  29 001e 243C 0000 		move.l #obDATA, %D2       	| p  = #obDATA
  29      0000 
  30 0024 7601      		move.l #1, %D3          	| size = 1
  31 0026 4E40      		trap #0
  32               	
  33               		/* FLAG CHECK */
  34 0028 0C80 0000 		cmp.l #0, %d0				/* see if PUTSTRING is successful */
  34      0000 
  35 002e 6700 FFD4 		beq outbyte_loop			/* if false, retry */
  36               	
  37               		/* SUCCESS */
  38 0032 4CDF 020E 		movem.l (%SP)+, %d1-%d3/%a1 /* RESTORE REGISTERS */
  39 0036 4E75      		rts
  40               	        
  41               	.section .bss
  42               	.even
  43               	
  44               	.global obDATA
  45               	obDATA:
  46 0000 00        		.ds.b 1
  47 0001 00        		.even




   1               	#NO_APP
   2               		.file	"csys68k.c"
   3               		.text
   4               	.Ltext0:
   5               		.cfi_sections	.debug_frame
   6               		.align	2
   7               		.globl	read
   8               		.type	read, @function
   9               	read:
  10               	.LVL0:
  11               	.LFB0:
  12               		.file 1 "csys68k.c"
   1:csys68k.c     **** extern void outbyte(unsigned char c);
   2:csys68k.c     **** extern char inbyte();
   3:csys68k.c     **** 
   4:csys68k.c     **** int read(int fd, char *buf, int nbytes)
   5:csys68k.c     **** {
  13               		.loc 1 5 1 view -0
  14               		.cfi_startproc
  15               		.loc 1 5 1 is_stmt 0 view .LVU1
  16 0000 48E7 3838 		movem.l #14392,-(%sp)
  17               		.cfi_def_cfa_offset 28
  18               		.cfi_offset 2, -28
  19               		.cfi_offset 3, -24
  20               		.cfi_offset 4, -20
  21               		.cfi_offset 10, -16
  22               		.cfi_offset 11, -12
  23               		.cfi_offset 12, -8
  24 0004 286F 0020 		move.l 32(%sp),%a4
  25 0008 282F 0024 		move.l 36(%sp),%d4
   6:csys68k.c     ****   char c;
  26               		.loc 1 6 3 is_stmt 1 view .LVU2
   7:csys68k.c     ****   int  i;
  27               		.loc 1 7 3 view .LVU3
   8:csys68k.c     **** 
   9:csys68k.c     ****   for (i = 0; i < nbytes; i++) {
  28               		.loc 1 9 3 view .LVU4
  29               	.LVL1:
  30               		.loc 1 9 17 view .LVU5
  31               		.loc 1 9 10 is_stmt 0 view .LVU6
  32 000c 7600      		moveq #0,%d3
  33               		.loc 1 9 17 view .LVU7
  34 000e 4A84      		tst.l %d4
  35 0010 6F36      		jle .L1
  36 0012 47F9 0000 		lea inbyte,%a3
  36      0000 
  37 0018 45F9 0000 		lea outbyte,%a2
  37      0000 
  38               	.LVL2:
  39               	.L8:
  10:csys68k.c     ****     c = inbyte();
  40               		.loc 1 10 5 is_stmt 1 view .LVU8
  41               		.loc 1 10 9 is_stmt 0 view .LVU9
  42 001e 4E93      		jsr (%a3)
  43               	.LVL3:
  44 0020 1400      		move.b %d0,%d2
  45               	.LVL4:


  11:csys68k.c     **** 
  12:csys68k.c     ****     if (c == '\r' || c == '\n'){ /* CR -> CRLF */
  46               		.loc 1 12 5 is_stmt 1 view .LVU10
  47               		.loc 1 12 8 is_stmt 0 view .LVU11
  48 0022 0C00 000D 		cmp.b #13,%d0
  49 0026 6728      		jeq .L3
  50               		.loc 1 12 19 discriminator 1 view .LVU12
  51 0028 0C00 000A 		cmp.b #10,%d0
  52 002c 6722      		jeq .L3
  13:csys68k.c     ****       outbyte('\r');
  14:csys68k.c     ****       outbyte('\n');
  15:csys68k.c     ****       *(buf + i) = '\n';
  16:csys68k.c     **** 
  17:csys68k.c     ****     /* } else if (c == '\x8'){ */     /* backspace \x8 */
  18:csys68k.c     ****     } else if (c == '\x7f'){      /* backspace \x8 -> \x7f (by terminal config.) */
  53               		.loc 1 18 12 is_stmt 1 view .LVU13
  54               		.loc 1 18 15 is_stmt 0 view .LVU14
  55 002e 0C00 007F 		cmp.b #127,%d0
  56 0032 673A      		jeq .L18
  19:csys68k.c     ****       if (i > 0){
  20:csys68k.c     **** 	outbyte('\x8'); /* bs  */
  21:csys68k.c     **** 	outbyte(' ');   /* spc */
  22:csys68k.c     **** 	outbyte('\x8'); /* bs  */
  23:csys68k.c     **** 	i--;
  24:csys68k.c     ****       }
  25:csys68k.c     ****       i--;
  26:csys68k.c     ****       continue;
  27:csys68k.c     **** 
  28:csys68k.c     ****     } else {
  29:csys68k.c     ****       outbyte(c);
  57               		.loc 1 29 7 is_stmt 1 view .LVU15
  58 0034 7000      		moveq #0,%d0
  59               	.LVL5:
  60               		.loc 1 29 7 is_stmt 0 view .LVU16
  61 0036 1002      		move.b %d2,%d0
  62 0038 2F00      		move.l %d0,-(%sp)
  63               		.cfi_def_cfa_offset 32
  64 003a 4E92      		jsr (%a2)
  65               	.LVL6:
  30:csys68k.c     ****       *(buf + i) = c;
  66               		.loc 1 30 7 is_stmt 1 view .LVU17
  67               		.loc 1 30 18 is_stmt 0 view .LVU18
  68 003c 1982 3800 		move.b %d2,(%a4,%d3.l)
  31:csys68k.c     ****     }
  32:csys68k.c     **** 
  33:csys68k.c     ****     if (*(buf + i) == '\n'){
  69               		.loc 1 33 5 is_stmt 1 view .LVU19
  34:csys68k.c     ****       return (i + 1);
  70               		.loc 1 34 17 is_stmt 0 view .LVU20
  71 0040 5283      		addq.l #1,%d3
  72               	.LVL7:
  73               		.loc 1 34 17 view .LVU21
  74 0042 588F      		addq.l #4,%sp
  75               		.cfi_def_cfa_offset 28
  76               	.LVL8:
   9:csys68k.c     ****     c = inbyte();
  77               		.loc 1 9 28 is_stmt 1 view .LVU22


   9:csys68k.c     ****     c = inbyte();
  78               		.loc 1 9 17 view .LVU23
  79 0044 B684      		cmp.l %d4,%d3
  80 0046 6DD6      		jlt .L8
  81               	.LVL9:
  82               	.L1:
  35:csys68k.c     ****     }
  36:csys68k.c     ****   }
  37:csys68k.c     ****   return (i);
  38:csys68k.c     **** }
  83               		.loc 1 38 1 is_stmt 0 view .LVU24
  84 0048 2003      		move.l %d3,%d0
  85 004a 4CDF 1C1C 		movem.l (%sp)+,#7196
  86 004e 4E75      		rts
  87               	.LVL10:
  88               	.L3:
  13:csys68k.c     ****       outbyte('\n');
  89               		.loc 1 13 7 is_stmt 1 view .LVU25
  90 0050 4878 000D 		pea 13.w
  91               		.cfi_def_cfa_offset 32
  92 0054 4E92      		jsr (%a2)
  93               	.LVL11:
  14:csys68k.c     ****       *(buf + i) = '\n';
  94               		.loc 1 14 7 view .LVU26
  95 0056 4878 000A 		pea 10.w
  96               		.cfi_def_cfa_offset 36
  97 005a 4E92      		jsr (%a2)
  98               	.LVL12:
  15:csys68k.c     **** 
  99               		.loc 1 15 7 view .LVU27
  15:csys68k.c     **** 
 100               		.loc 1 15 18 is_stmt 0 view .LVU28
 101 005c 19BC 000A 		move.b #10,(%a4,%d3.l)
 101      3800 
  33:csys68k.c     ****       return (i + 1);
 102               		.loc 1 33 5 is_stmt 1 view .LVU29
  34:csys68k.c     ****     }
 103               		.loc 1 34 7 view .LVU30
  34:csys68k.c     ****     }
 104               		.loc 1 34 17 is_stmt 0 view .LVU31
 105 0062 5283      		addq.l #1,%d3
 106               	.LVL13:
  34:csys68k.c     ****     }
 107               		.loc 1 34 17 view .LVU32
 108 0064 508F      		addq.l #8,%sp
 109               		.cfi_def_cfa_offset 28
 110               		.loc 1 38 1 view .LVU33
 111 0066 2003      		move.l %d3,%d0
 112 0068 4CDF 1C1C 		movem.l (%sp)+,#7196
 113               	.LVL14:
 114               		.loc 1 38 1 view .LVU34
 115 006c 4E75      		rts
 116               	.LVL15:
 117               	.L18:
  19:csys68k.c     **** 	outbyte('\x8'); /* bs  */
 118               		.loc 1 19 7 is_stmt 1 view .LVU35
  19:csys68k.c     **** 	outbyte('\x8'); /* bs  */


 119               		.loc 1 19 10 is_stmt 0 view .LVU36
 120 006e 4A83      		tst.l %d3
 121 0070 67AC      		jeq .L8
  23:csys68k.c     ****       }
 122               		.loc 1 23 3 view .LVU37
 123 0072 5383      		subq.l #1,%d3
 124               	.LVL16:
  20:csys68k.c     **** 	outbyte(' ');   /* spc */
 125               		.loc 1 20 2 is_stmt 1 view .LVU38
 126 0074 4878 0008 		pea 8.w
 127               		.cfi_def_cfa_offset 32
 128 0078 4E92      		jsr (%a2)
 129               	.LVL17:
  21:csys68k.c     **** 	outbyte('\x8'); /* bs  */
 130               		.loc 1 21 2 view .LVU39
 131 007a 4878 0020 		pea 32.w
 132               		.cfi_def_cfa_offset 36
 133 007e 4E92      		jsr (%a2)
 134               	.LVL18:
  22:csys68k.c     **** 	i--;
 135               		.loc 1 22 2 view .LVU40
 136 0080 4878 0008 		pea 8.w
 137               		.cfi_def_cfa_offset 40
 138 0084 4E92      		jsr (%a2)
 139               	.LVL19:
  23:csys68k.c     ****       }
 140               		.loc 1 23 2 view .LVU41
  25:csys68k.c     ****       continue;
 141               		.loc 1 25 7 view .LVU42
  26:csys68k.c     **** 
 142               		.loc 1 26 7 view .LVU43
 143 0086 4FEF 000C 		lea (12,%sp),%sp
 144               		.cfi_def_cfa_offset 28
 145               	.LVL20:
   9:csys68k.c     ****     c = inbyte();
 146               		.loc 1 9 28 view .LVU44
   9:csys68k.c     ****     c = inbyte();
 147               		.loc 1 9 17 view .LVU45
 148 008a B684      		cmp.l %d4,%d3
 149 008c 6D90      		jlt .L8
 150 008e 60B8      		jra .L1
 151               		.cfi_endproc
 152               	.LFE0:
 153               		.size	read, .-read
 154               		.align	2
 155               		.globl	write
 156               		.type	write, @function
 157               	write:
 158               	.LVL21:
 159               	.LFB1:
  39:csys68k.c     **** 
  40:csys68k.c     **** int write (int fd, char *buf, int nbytes)
  41:csys68k.c     **** {
 160               		.loc 1 41 1 view -0
 161               		.cfi_startproc
 162               		.loc 1 41 1 is_stmt 0 view .LVU47
 163 0090 48E7 3030 		movem.l #12336,-(%sp)


 164               		.cfi_def_cfa_offset 20
 165               		.cfi_offset 2, -20
 166               		.cfi_offset 3, -16
 167               		.cfi_offset 10, -12
 168               		.cfi_offset 11, -8
 169 0094 262F 001C 		move.l 28(%sp),%d3
  42:csys68k.c     ****   int i, j;
 170               		.loc 1 42 3 is_stmt 1 view .LVU48
  43:csys68k.c     ****   for (i = 0; i < nbytes; i++) {
 171               		.loc 1 43 3 view .LVU49
 172               	.LVL22:
 173               		.loc 1 43 17 view .LVU50
 174 0098 6F26      		jle .L25
 175 009a 246F 0018 		move.l 24(%sp),%a2
 176 009e 240A      		move.l %a2,%d2
 177 00a0 D483      		add.l %d3,%d2
 178 00a2 47F9 0000 		lea outbyte,%a3
 178      0000 
 179               	.LVL23:
 180               	.L22:
  44:csys68k.c     ****     if (*(buf + i) == '\n') {
 181               		.loc 1 44 5 view .LVU51
 182               		.loc 1 44 9 is_stmt 0 view .LVU52
 183 00a8 101A      		move.b (%a2)+,%d0
 184               	.LVL24:
 185               		.loc 1 44 8 view .LVU53
 186 00aa 0C00 000A 		cmp.b #10,%d0
 187 00ae 6718      		jeq .L28
  45:csys68k.c     ****       outbyte ('\r');          /* LF -> CRLF */
  46:csys68k.c     ****     }
  47:csys68k.c     ****     outbyte (*(buf + i));
 188               		.loc 1 47 5 is_stmt 1 view .LVU54
 189 00b0 0280 0000 		and.l #255,%d0
 189      00FF 
 190 00b6 2F00      		move.l %d0,-(%sp)
 191               		.cfi_def_cfa_offset 24
 192 00b8 4E93      		jsr (%a3)
 193               	.LVL25:
  48:csys68k.c     ****     for (j = 0; j < 300; j++);
 194               		.loc 1 48 5 view .LVU55
 195               		.loc 1 48 19 view .LVU56
  43:csys68k.c     ****     if (*(buf + i) == '\n') {
 196               		.loc 1 43 28 view .LVU57
  43:csys68k.c     ****     if (*(buf + i) == '\n') {
 197               		.loc 1 43 17 view .LVU58
 198 00ba 588F      		addq.l #4,%sp
 199               		.cfi_def_cfa_offset 20
 200 00bc B48A      		cmp.l %a2,%d2
 201 00be 66E8      		jne .L22
 202               	.LVL26:
 203               	.L25:
  49:csys68k.c     ****   }
  50:csys68k.c     ****   return (nbytes);
  51:csys68k.c     **** }
 204               		.loc 1 51 1 is_stmt 0 view .LVU59
 205 00c0 2003      		move.l %d3,%d0
 206 00c2 4CDF 0C0C 		movem.l (%sp)+,#3084


 207 00c6 4E75      		rts
 208               	.LVL27:
 209               	.L28:
  45:csys68k.c     ****     }
 210               		.loc 1 45 7 is_stmt 1 view .LVU60
 211 00c8 4878 000D 		pea 13.w
 212               		.cfi_def_cfa_offset 24
 213 00cc 4E93      		jsr (%a3)
 214               	.LVL28:
  47:csys68k.c     ****     for (j = 0; j < 300; j++);
 215               		.loc 1 47 14 is_stmt 0 view .LVU61
 216 00ce 102A FFFF 		move.b -1(%a2),%d0
 217 00d2 588F      		addq.l #4,%sp
 218               		.cfi_def_cfa_offset 20
  47:csys68k.c     ****     for (j = 0; j < 300; j++);
 219               		.loc 1 47 5 is_stmt 1 view .LVU62
 220 00d4 0280 0000 		and.l #255,%d0
 220      00FF 
 221 00da 2F00      		move.l %d0,-(%sp)
 222               		.cfi_def_cfa_offset 24
 223 00dc 4E93      		jsr (%a3)
 224               	.LVL29:
  48:csys68k.c     ****   }
 225               		.loc 1 48 5 view .LVU63
  48:csys68k.c     ****   }
 226               		.loc 1 48 19 view .LVU64
  43:csys68k.c     ****     if (*(buf + i) == '\n') {
 227               		.loc 1 43 28 view .LVU65
  43:csys68k.c     ****     if (*(buf + i) == '\n') {
 228               		.loc 1 43 17 view .LVU66
 229 00de 588F      		addq.l #4,%sp
 230               		.cfi_def_cfa_offset 20
 231 00e0 B48A      		cmp.l %a2,%d2
 232 00e2 66C4      		jne .L22
 233 00e4 60DA      		jra .L25
 234               		.cfi_endproc
 235               	.LFE1:
 236               		.size	write, .-write
 237               	.Letext0:
 238               		.section	.debug_info,"",@progbits
 239               	.Ldebug_info0:
 240 0000 0000 017B 		.long	0x17b
 241 0004 0005      		.word	0x5
 242 0006 01        		.byte	0x1
 243 0007 04        		.byte	0x4
 244 0008 0000 0000 		.long	.Ldebug_abbrev0
 245 000c 06        		.uleb128 0x6
 246 000d 0000 0000 		.long	.LASF5
 247 0011 1D        		.byte	0x1d
 248 0012 0000 0000 		.long	.LASF6
 249 0016 0000 0000 		.long	.LASF7
 250 001a 0000 0000 		.long	.Ltext0
 251 001e 0000 00E6 		.long	.Letext0-.Ltext0
 252 0022 0000 0000 		.long	.Ldebug_line0
 253 0026 07        		.uleb128 0x7
 254 0027 0000 0000 		.long	.LASF0
 255 002b 01        		.byte	0x1


 256 002c 01        		.byte	0x1
 257 002d 0D        		.byte	0xd
 258 002e 0000 0038 		.long	0x38
 259 0032 08        		.uleb128 0x8
 260 0033 0000 0038 		.long	0x38
 261 0037 00        		.byte	0
 262 0038 04        		.uleb128 0x4
 263 0039 08        		.byte	0x8
 264 003a 0000 0000 		.long	.LASF2
 265 003e 09        		.uleb128 0x9
 266 003f 0000 0000 		.long	.LASF1
 267 0043 01        		.byte	0x1
 268 0044 02        		.byte	0x2
 269 0045 0D        		.byte	0xd
 270 0046 0000 0050 		.long	0x50
 271 004a 0000 0050 		.long	0x50
 272 004e 0A        		.uleb128 0xa
 273 004f 00        		.byte	0
 274 0050 04        		.uleb128 0x4
 275 0051 06        		.byte	0x6
 276 0052 0000 0000 		.long	.LASF3
 277 0056 0B        		.uleb128 0xb
 278 0057 0000 0000 		.long	.LASF8
 279 005b 01        		.byte	0x1
 280 005c 28        		.byte	0x28
 281 005d 05        		.byte	0x5
 282 005e 0000 00D0 		.long	0xd0
 283 0062 0000 0000 		.long	.LFB1
 284 0066 0000 0056 		.long	.LFE1-.LFB1
 285 006a 01        		.uleb128 0x1
 286 006b 9C        		.byte	0x9c
 287 006c 0000 00D0 		.long	0xd0
 288 0070 02        		.uleb128 0x2
 289 0071 6664 00   		.string	"fd"
 290 0074 28        		.byte	0x28
 291 0075 10        		.byte	0x10
 292 0076 0000 00D0 		.long	0xd0
 293 007a 02        		.uleb128 0x2
 294 007b 91        		.byte	0x91
 295 007c 00        		.sleb128 0
 296 007d 02        		.uleb128 0x2
 297 007e 6275 6600 		.string	"buf"
 298 0082 28        		.byte	0x28
 299 0083 1A        		.byte	0x1a
 300 0084 0000 00D7 		.long	0xd7
 301 0088 02        		.uleb128 0x2
 302 0089 91        		.byte	0x91
 303 008a 04        		.sleb128 4
 304 008b 05        		.uleb128 0x5
 305 008c 0000 0000 		.long	.LASF4
 306 0090 28        		.byte	0x28
 307 0091 23        		.byte	0x23
 308 0092 0000 00D0 		.long	0xd0
 309 0096 02        		.uleb128 0x2
 310 0097 91        		.byte	0x91
 311 0098 08        		.sleb128 8
 312 0099 03        		.uleb128 0x3


 313 009a 6900      		.string	"i"
 314 009c 2A        		.byte	0x2a
 315 009d 07        		.byte	0x7
 316 009e 0000 00D0 		.long	0xd0
 317 00a2 0000 0000 		.long	.LLST2
 318 00a6 0000 0000 		.long	.LVUS2
 319 00aa 0C        		.uleb128 0xc
 320 00ab 6A00      		.string	"j"
 321 00ad 01        		.byte	0x1
 322 00ae 2A        		.byte	0x2a
 323 00af 0A        		.byte	0xa
 324 00b0 0000 00D0 		.long	0xd0
 325 00b4 01        		.uleb128 0x1
 326 00b5 0000 0000 		.long	.LVL25
 327 00b9 0000 0026 		.long	0x26
 328 00bd 01        		.uleb128 0x1
 329 00be 0000 0000 		.long	.LVL28
 330 00c2 0000 0026 		.long	0x26
 331 00c6 01        		.uleb128 0x1
 332 00c7 0000 0000 		.long	.LVL29
 333 00cb 0000 0026 		.long	0x26
 334 00cf 00        		.byte	0
 335 00d0 0D        		.uleb128 0xd
 336 00d1 04        		.byte	0x4
 337 00d2 05        		.byte	0x5
 338 00d3 696E 7400 		.string	"int"
 339 00d7 0E        		.uleb128 0xe
 340 00d8 04        		.byte	0x4
 341 00d9 0000 0050 		.long	0x50
 342 00dd 0F        		.uleb128 0xf
 343 00de 0000 0000 		.long	.LASF9
 344 00e2 01        		.byte	0x1
 345 00e3 04        		.byte	0x4
 346 00e4 05        		.byte	0x5
 347 00e5 0000 00D0 		.long	0xd0
 348 00e9 0000 0000 		.long	.LFB0
 349 00ed 0000 0090 		.long	.LFE0-.LFB0
 350 00f1 01        		.uleb128 0x1
 351 00f2 9C        		.byte	0x9c
 352 00f3 02        		.uleb128 0x2
 353 00f4 6664 00   		.string	"fd"
 354 00f7 04        		.byte	0x4
 355 00f8 0E        		.byte	0xe
 356 00f9 0000 00D0 		.long	0xd0
 357 00fd 02        		.uleb128 0x2
 358 00fe 91        		.byte	0x91
 359 00ff 00        		.sleb128 0
 360 0100 02        		.uleb128 0x2
 361 0101 6275 6600 		.string	"buf"
 362 0105 04        		.byte	0x4
 363 0106 18        		.byte	0x18
 364 0107 0000 00D7 		.long	0xd7
 365 010b 02        		.uleb128 0x2
 366 010c 91        		.byte	0x91
 367 010d 04        		.sleb128 4
 368 010e 05        		.uleb128 0x5
 369 010f 0000 0000 		.long	.LASF4


 370 0113 04        		.byte	0x4
 371 0114 21        		.byte	0x21
 372 0115 0000 00D0 		.long	0xd0
 373 0119 02        		.uleb128 0x2
 374 011a 91        		.byte	0x91
 375 011b 08        		.sleb128 8
 376 011c 03        		.uleb128 0x3
 377 011d 6300      		.string	"c"
 378 011f 06        		.byte	0x6
 379 0120 08        		.byte	0x8
 380 0121 0000 0050 		.long	0x50
 381 0125 0000 0000 		.long	.LLST0
 382 0129 0000 0000 		.long	.LVUS0
 383 012d 03        		.uleb128 0x3
 384 012e 6900      		.string	"i"
 385 0130 07        		.byte	0x7
 386 0131 08        		.byte	0x8
 387 0132 0000 00D0 		.long	0xd0
 388 0136 0000 0000 		.long	.LLST1
 389 013a 0000 0000 		.long	.LVUS1
 390 013e 01        		.uleb128 0x1
 391 013f 0000 0000 		.long	.LVL3
 392 0143 0000 003E 		.long	0x3e
 393 0147 01        		.uleb128 0x1
 394 0148 0000 0000 		.long	.LVL6
 395 014c 0000 0026 		.long	0x26
 396 0150 01        		.uleb128 0x1
 397 0151 0000 0000 		.long	.LVL11
 398 0155 0000 0026 		.long	0x26
 399 0159 01        		.uleb128 0x1
 400 015a 0000 0000 		.long	.LVL12
 401 015e 0000 0026 		.long	0x26
 402 0162 01        		.uleb128 0x1
 403 0163 0000 0000 		.long	.LVL17
 404 0167 0000 0026 		.long	0x26
 405 016b 01        		.uleb128 0x1
 406 016c 0000 0000 		.long	.LVL18
 407 0170 0000 0026 		.long	0x26
 408 0174 01        		.uleb128 0x1
 409 0175 0000 0000 		.long	.LVL19
 410 0179 0000 0026 		.long	0x26
 411 017d 00        		.byte	0
 412 017e 00        		.byte	0
 413               		.section	.debug_abbrev,"",@progbits
 414               	.Ldebug_abbrev0:
 415 0000 01        		.uleb128 0x1
 416 0001 48        		.uleb128 0x48
 417 0002 00        		.byte	0
 418 0003 7D        		.uleb128 0x7d
 419 0004 01        		.uleb128 0x1
 420 0005 7F        		.uleb128 0x7f
 421 0006 13        		.uleb128 0x13
 422 0007 00        		.byte	0
 423 0008 00        		.byte	0
 424 0009 02        		.uleb128 0x2
 425 000a 05        		.uleb128 0x5
 426 000b 00        		.byte	0


 427 000c 03        		.uleb128 0x3
 428 000d 08        		.uleb128 0x8
 429 000e 3A        		.uleb128 0x3a
 430 000f 21        		.uleb128 0x21
 431 0010 01        		.sleb128 1
 432 0011 3B        		.uleb128 0x3b
 433 0012 0B        		.uleb128 0xb
 434 0013 39        		.uleb128 0x39
 435 0014 0B        		.uleb128 0xb
 436 0015 49        		.uleb128 0x49
 437 0016 13        		.uleb128 0x13
 438 0017 02        		.uleb128 0x2
 439 0018 18        		.uleb128 0x18
 440 0019 00        		.byte	0
 441 001a 00        		.byte	0
 442 001b 03        		.uleb128 0x3
 443 001c 34        		.uleb128 0x34
 444 001d 00        		.byte	0
 445 001e 03        		.uleb128 0x3
 446 001f 08        		.uleb128 0x8
 447 0020 3A        		.uleb128 0x3a
 448 0021 21        		.uleb128 0x21
 449 0022 01        		.sleb128 1
 450 0023 3B        		.uleb128 0x3b
 451 0024 0B        		.uleb128 0xb
 452 0025 39        		.uleb128 0x39
 453 0026 0B        		.uleb128 0xb
 454 0027 49        		.uleb128 0x49
 455 0028 13        		.uleb128 0x13
 456 0029 02        		.uleb128 0x2
 457 002a 17        		.uleb128 0x17
 458 002b B742      		.uleb128 0x2137
 459 002d 17        		.uleb128 0x17
 460 002e 00        		.byte	0
 461 002f 00        		.byte	0
 462 0030 04        		.uleb128 0x4
 463 0031 24        		.uleb128 0x24
 464 0032 00        		.byte	0
 465 0033 0B        		.uleb128 0xb
 466 0034 21        		.uleb128 0x21
 467 0035 01        		.sleb128 1
 468 0036 3E        		.uleb128 0x3e
 469 0037 0B        		.uleb128 0xb
 470 0038 03        		.uleb128 0x3
 471 0039 0E        		.uleb128 0xe
 472 003a 00        		.byte	0
 473 003b 00        		.byte	0
 474 003c 05        		.uleb128 0x5
 475 003d 05        		.uleb128 0x5
 476 003e 00        		.byte	0
 477 003f 03        		.uleb128 0x3
 478 0040 0E        		.uleb128 0xe
 479 0041 3A        		.uleb128 0x3a
 480 0042 21        		.uleb128 0x21
 481 0043 01        		.sleb128 1
 482 0044 3B        		.uleb128 0x3b
 483 0045 0B        		.uleb128 0xb


 484 0046 39        		.uleb128 0x39
 485 0047 0B        		.uleb128 0xb
 486 0048 49        		.uleb128 0x49
 487 0049 13        		.uleb128 0x13
 488 004a 02        		.uleb128 0x2
 489 004b 18        		.uleb128 0x18
 490 004c 00        		.byte	0
 491 004d 00        		.byte	0
 492 004e 06        		.uleb128 0x6
 493 004f 11        		.uleb128 0x11
 494 0050 01        		.byte	0x1
 495 0051 25        		.uleb128 0x25
 496 0052 0E        		.uleb128 0xe
 497 0053 13        		.uleb128 0x13
 498 0054 0B        		.uleb128 0xb
 499 0055 03        		.uleb128 0x3
 500 0056 0E        		.uleb128 0xe
 501 0057 1B        		.uleb128 0x1b
 502 0058 0E        		.uleb128 0xe
 503 0059 11        		.uleb128 0x11
 504 005a 01        		.uleb128 0x1
 505 005b 12        		.uleb128 0x12
 506 005c 06        		.uleb128 0x6
 507 005d 10        		.uleb128 0x10
 508 005e 17        		.uleb128 0x17
 509 005f 00        		.byte	0
 510 0060 00        		.byte	0
 511 0061 07        		.uleb128 0x7
 512 0062 2E        		.uleb128 0x2e
 513 0063 01        		.byte	0x1
 514 0064 3F        		.uleb128 0x3f
 515 0065 19        		.uleb128 0x19
 516 0066 03        		.uleb128 0x3
 517 0067 0E        		.uleb128 0xe
 518 0068 3A        		.uleb128 0x3a
 519 0069 0B        		.uleb128 0xb
 520 006a 3B        		.uleb128 0x3b
 521 006b 0B        		.uleb128 0xb
 522 006c 39        		.uleb128 0x39
 523 006d 0B        		.uleb128 0xb
 524 006e 27        		.uleb128 0x27
 525 006f 19        		.uleb128 0x19
 526 0070 3C        		.uleb128 0x3c
 527 0071 19        		.uleb128 0x19
 528 0072 01        		.uleb128 0x1
 529 0073 13        		.uleb128 0x13
 530 0074 00        		.byte	0
 531 0075 00        		.byte	0
 532 0076 08        		.uleb128 0x8
 533 0077 05        		.uleb128 0x5
 534 0078 00        		.byte	0
 535 0079 49        		.uleb128 0x49
 536 007a 13        		.uleb128 0x13
 537 007b 00        		.byte	0
 538 007c 00        		.byte	0
 539 007d 09        		.uleb128 0x9
 540 007e 2E        		.uleb128 0x2e


 541 007f 01        		.byte	0x1
 542 0080 3F        		.uleb128 0x3f
 543 0081 19        		.uleb128 0x19
 544 0082 03        		.uleb128 0x3
 545 0083 0E        		.uleb128 0xe
 546 0084 3A        		.uleb128 0x3a
 547 0085 0B        		.uleb128 0xb
 548 0086 3B        		.uleb128 0x3b
 549 0087 0B        		.uleb128 0xb
 550 0088 39        		.uleb128 0x39
 551 0089 0B        		.uleb128 0xb
 552 008a 49        		.uleb128 0x49
 553 008b 13        		.uleb128 0x13
 554 008c 3C        		.uleb128 0x3c
 555 008d 19        		.uleb128 0x19
 556 008e 01        		.uleb128 0x1
 557 008f 13        		.uleb128 0x13
 558 0090 00        		.byte	0
 559 0091 00        		.byte	0
 560 0092 0A        		.uleb128 0xa
 561 0093 18        		.uleb128 0x18
 562 0094 00        		.byte	0
 563 0095 00        		.byte	0
 564 0096 00        		.byte	0
 565 0097 0B        		.uleb128 0xb
 566 0098 2E        		.uleb128 0x2e
 567 0099 01        		.byte	0x1
 568 009a 3F        		.uleb128 0x3f
 569 009b 19        		.uleb128 0x19
 570 009c 03        		.uleb128 0x3
 571 009d 0E        		.uleb128 0xe
 572 009e 3A        		.uleb128 0x3a
 573 009f 0B        		.uleb128 0xb
 574 00a0 3B        		.uleb128 0x3b
 575 00a1 0B        		.uleb128 0xb
 576 00a2 39        		.uleb128 0x39
 577 00a3 0B        		.uleb128 0xb
 578 00a4 27        		.uleb128 0x27
 579 00a5 19        		.uleb128 0x19
 580 00a6 49        		.uleb128 0x49
 581 00a7 13        		.uleb128 0x13
 582 00a8 11        		.uleb128 0x11
 583 00a9 01        		.uleb128 0x1
 584 00aa 12        		.uleb128 0x12
 585 00ab 06        		.uleb128 0x6
 586 00ac 40        		.uleb128 0x40
 587 00ad 18        		.uleb128 0x18
 588 00ae 7A        		.uleb128 0x7a
 589 00af 19        		.uleb128 0x19
 590 00b0 01        		.uleb128 0x1
 591 00b1 13        		.uleb128 0x13
 592 00b2 00        		.byte	0
 593 00b3 00        		.byte	0
 594 00b4 0C        		.uleb128 0xc
 595 00b5 34        		.uleb128 0x34
 596 00b6 00        		.byte	0
 597 00b7 03        		.uleb128 0x3


 598 00b8 08        		.uleb128 0x8
 599 00b9 3A        		.uleb128 0x3a
 600 00ba 0B        		.uleb128 0xb
 601 00bb 3B        		.uleb128 0x3b
 602 00bc 0B        		.uleb128 0xb
 603 00bd 39        		.uleb128 0x39
 604 00be 0B        		.uleb128 0xb
 605 00bf 49        		.uleb128 0x49
 606 00c0 13        		.uleb128 0x13
 607 00c1 00        		.byte	0
 608 00c2 00        		.byte	0
 609 00c3 0D        		.uleb128 0xd
 610 00c4 24        		.uleb128 0x24
 611 00c5 00        		.byte	0
 612 00c6 0B        		.uleb128 0xb
 613 00c7 0B        		.uleb128 0xb
 614 00c8 3E        		.uleb128 0x3e
 615 00c9 0B        		.uleb128 0xb
 616 00ca 03        		.uleb128 0x3
 617 00cb 08        		.uleb128 0x8
 618 00cc 00        		.byte	0
 619 00cd 00        		.byte	0
 620 00ce 0E        		.uleb128 0xe
 621 00cf 0F        		.uleb128 0xf
 622 00d0 00        		.byte	0
 623 00d1 0B        		.uleb128 0xb
 624 00d2 0B        		.uleb128 0xb
 625 00d3 49        		.uleb128 0x49
 626 00d4 13        		.uleb128 0x13
 627 00d5 00        		.byte	0
 628 00d6 00        		.byte	0
 629 00d7 0F        		.uleb128 0xf
 630 00d8 2E        		.uleb128 0x2e
 631 00d9 01        		.byte	0x1
 632 00da 3F        		.uleb128 0x3f
 633 00db 19        		.uleb128 0x19
 634 00dc 03        		.uleb128 0x3
 635 00dd 0E        		.uleb128 0xe
 636 00de 3A        		.uleb128 0x3a
 637 00df 0B        		.uleb128 0xb
 638 00e0 3B        		.uleb128 0x3b
 639 00e1 0B        		.uleb128 0xb
 640 00e2 39        		.uleb128 0x39
 641 00e3 0B        		.uleb128 0xb
 642 00e4 27        		.uleb128 0x27
 643 00e5 19        		.uleb128 0x19
 644 00e6 49        		.uleb128 0x49
 645 00e7 13        		.uleb128 0x13
 646 00e8 11        		.uleb128 0x11
 647 00e9 01        		.uleb128 0x1
 648 00ea 12        		.uleb128 0x12
 649 00eb 06        		.uleb128 0x6
 650 00ec 40        		.uleb128 0x40
 651 00ed 18        		.uleb128 0x18
 652 00ee 7A        		.uleb128 0x7a
 653 00ef 19        		.uleb128 0x19
 654 00f0 00        		.byte	0


 655 00f1 00        		.byte	0
 656 00f2 00        		.byte	0
 657               		.section	.debug_loclists,"",@progbits
 658 0000 0000 00E3 		.long	.Ldebug_loc3-.Ldebug_loc2
 659               	.Ldebug_loc2:
 660 0004 0005      		.word	0x5
 661 0006 04        		.byte	0x4
 662 0007 00        		.byte	0
 663 0008 0000 0000 		.long	0
 664               	.Ldebug_loc0:
 665               	.LVUS2:
 666 000c 02        		.uleb128 .LVU50
 667 000d 00        		.uleb128 .LVU51
 668 000e 00        		.uleb128 .LVU51
 669 000f 00        		.uleb128 .LVU53
 670 0010 00        		.uleb128 .LVU53
 671 0011 03        		.uleb128 .LVU58
 672 0012 03        		.uleb128 .LVU58
 673 0013 00        		.uleb128 .LVU59
 674 0014 00        		.uleb128 .LVU60
 675 0015 03        		.uleb128 .LVU66
 676 0016 03        		.uleb128 .LVU66
 677 0017 00        		.uleb128 0
 678               	.LLST2:
 679 0018 04        		.byte	0x4
 680 0019 9801      		.uleb128 .LVL22-.Ltext0
 681 001b A801      		.uleb128 .LVL23-.Ltext0
 682 001d 02        		.uleb128 0x2
 683 001e 30        		.byte	0x30
 684 001f 9F        		.byte	0x9f
 685 0020 04        		.byte	0x4
 686 0021 A801      		.uleb128 .LVL23-.Ltext0
 687 0023 AA01      		.uleb128 .LVL24-.Ltext0
 688 0025 07        		.uleb128 0x7
 689 0026 7A        		.byte	0x7a
 690 0027 00        		.sleb128 0
 691 0028 91        		.byte	0x91
 692 0029 74        		.sleb128 -12
 693 002a 06        		.byte	0x6
 694 002b 1C        		.byte	0x1c
 695 002c 9F        		.byte	0x9f
 696 002d 04        		.byte	0x4
 697 002e AA01      		.uleb128 .LVL24-.Ltext0
 698 0030 BA01      		.uleb128 .LVL25-.Ltext0
 699 0032 08        		.uleb128 0x8
 700 0033 91        		.byte	0x91
 701 0034 74        		.sleb128 -12
 702 0035 06        		.byte	0x6
 703 0036 20        		.byte	0x20
 704 0037 7A        		.byte	0x7a
 705 0038 00        		.sleb128 0
 706 0039 22        		.byte	0x22
 707 003a 9F        		.byte	0x9f
 708 003b 04        		.byte	0x4
 709 003c BA01      		.uleb128 .LVL25-.Ltext0
 710 003e C001      		.uleb128 .LVL26-.Ltext0
 711 0040 07        		.uleb128 0x7


 712 0041 7A        		.byte	0x7a
 713 0042 00        		.sleb128 0
 714 0043 91        		.byte	0x91
 715 0044 74        		.sleb128 -12
 716 0045 06        		.byte	0x6
 717 0046 1C        		.byte	0x1c
 718 0047 9F        		.byte	0x9f
 719 0048 04        		.byte	0x4
 720 0049 C801      		.uleb128 .LVL27-.Ltext0
 721 004b DE01      		.uleb128 .LVL29-.Ltext0
 722 004d 08        		.uleb128 0x8
 723 004e 91        		.byte	0x91
 724 004f 74        		.sleb128 -12
 725 0050 06        		.byte	0x6
 726 0051 20        		.byte	0x20
 727 0052 7A        		.byte	0x7a
 728 0053 00        		.sleb128 0
 729 0054 22        		.byte	0x22
 730 0055 9F        		.byte	0x9f
 731 0056 04        		.byte	0x4
 732 0057 DE01      		.uleb128 .LVL29-.Ltext0
 733 0059 E601      		.uleb128 .LFE1-.Ltext0
 734 005b 07        		.uleb128 0x7
 735 005c 7A        		.byte	0x7a
 736 005d 00        		.sleb128 0
 737 005e 91        		.byte	0x91
 738 005f 74        		.sleb128 -12
 739 0060 06        		.byte	0x6
 740 0061 1C        		.byte	0x1c
 741 0062 9F        		.byte	0x9f
 742 0063 00        		.byte	0
 743               	.LVUS0:
 744 0064 00        		.uleb128 .LVU10
 745 0065 00        		.uleb128 .LVU16
 746 0066 00        		.uleb128 .LVU16
 747 0067 00        		.uleb128 .LVU24
 748 0068 00        		.uleb128 .LVU25
 749 0069 00        		.uleb128 .LVU26
 750 006a 00        		.uleb128 .LVU26
 751 006b 00        		.uleb128 .LVU34
 752 006c 00        		.uleb128 .LVU35
 753 006d 00        		.uleb128 .LVU39
 754 006e 00        		.uleb128 .LVU39
 755 006f 00        		.uleb128 0
 756               	.LLST0:
 757 0070 04        		.byte	0x4
 758 0071 22        		.uleb128 .LVL4-.Ltext0
 759 0072 36        		.uleb128 .LVL5-.Ltext0
 760 0073 01        		.uleb128 0x1
 761 0074 50        		.byte	0x50
 762 0075 04        		.byte	0x4
 763 0076 36        		.uleb128 .LVL5-.Ltext0
 764 0077 48        		.uleb128 .LVL9-.Ltext0
 765 0078 01        		.uleb128 0x1
 766 0079 52        		.byte	0x52
 767 007a 04        		.byte	0x4
 768 007b 50        		.uleb128 .LVL10-.Ltext0


 769 007c 55        		.uleb128 .LVL11-1-.Ltext0
 770 007d 01        		.uleb128 0x1
 771 007e 50        		.byte	0x50
 772 007f 04        		.byte	0x4
 773 0080 55        		.uleb128 .LVL11-1-.Ltext0
 774 0081 6C        		.uleb128 .LVL14-.Ltext0
 775 0082 01        		.uleb128 0x1
 776 0083 52        		.byte	0x52
 777 0084 04        		.byte	0x4
 778 0085 6E        		.uleb128 .LVL15-.Ltext0
 779 0086 79        		.uleb128 .LVL17-1-.Ltext0
 780 0087 01        		.uleb128 0x1
 781 0088 50        		.byte	0x50
 782 0089 04        		.byte	0x4
 783 008a 79        		.uleb128 .LVL17-1-.Ltext0
 784 008b 9001      		.uleb128 .LFE0-.Ltext0
 785 008d 01        		.uleb128 0x1
 786 008e 52        		.byte	0x52
 787 008f 00        		.byte	0
 788               	.LVUS1:
 789 0090 03        		.uleb128 .LVU5
 790 0091 00        		.uleb128 .LVU8
 791 0092 00        		.uleb128 .LVU8
 792 0093 00        		.uleb128 .LVU21
 793 0094 00        		.uleb128 .LVU21
 794 0095 00        		.uleb128 .LVU22
 795 0096 00        		.uleb128 .LVU25
 796 0097 00        		.uleb128 .LVU32
 797 0098 00        		.uleb128 .LVU32
 798 0099 00        		.uleb128 .LVU34
 799 009a 00        		.uleb128 .LVU34
 800 009b 00        		.uleb128 .LVU35
 801 009c 00        		.uleb128 .LVU35
 802 009d 00        		.uleb128 .LVU38
 803 009e 00        		.uleb128 .LVU38
 804 009f 01        		.uleb128 .LVU42
 805 00a0 01        		.uleb128 .LVU42
 806 00a1 02        		.uleb128 .LVU43
 807 00a2 02        		.uleb128 .LVU43
 808 00a3 00        		.uleb128 .LVU44
 809               	.LLST1:
 810 00a4 04        		.byte	0x4
 811 00a5 0C        		.uleb128 .LVL1-.Ltext0
 812 00a6 1E        		.uleb128 .LVL2-.Ltext0
 813 00a7 02        		.uleb128 0x2
 814 00a8 30        		.byte	0x30
 815 00a9 9F        		.byte	0x9f
 816 00aa 04        		.byte	0x4
 817 00ab 1E        		.uleb128 .LVL2-.Ltext0
 818 00ac 42        		.uleb128 .LVL7-.Ltext0
 819 00ad 01        		.uleb128 0x1
 820 00ae 53        		.byte	0x53
 821 00af 04        		.byte	0x4
 822 00b0 42        		.uleb128 .LVL7-.Ltext0
 823 00b1 44        		.uleb128 .LVL8-.Ltext0
 824 00b2 03        		.uleb128 0x3
 825 00b3 73        		.byte	0x73


 826 00b4 7F        		.sleb128 -1
 827 00b5 9F        		.byte	0x9f
 828 00b6 04        		.byte	0x4
 829 00b7 50        		.uleb128 .LVL10-.Ltext0
 830 00b8 64        		.uleb128 .LVL13-.Ltext0
 831 00b9 01        		.uleb128 0x1
 832 00ba 53        		.byte	0x53
 833 00bb 04        		.byte	0x4
 834 00bc 64        		.uleb128 .LVL13-.Ltext0
 835 00bd 6C        		.uleb128 .LVL14-.Ltext0
 836 00be 03        		.uleb128 0x3
 837 00bf 73        		.byte	0x73
 838 00c0 7F        		.sleb128 -1
 839 00c1 9F        		.byte	0x9f
 840 00c2 04        		.byte	0x4
 841 00c3 6C        		.uleb128 .LVL14-.Ltext0
 842 00c4 6E        		.uleb128 .LVL15-.Ltext0
 843 00c5 03        		.uleb128 0x3
 844 00c6 70        		.byte	0x70
 845 00c7 7F        		.sleb128 -1
 846 00c8 9F        		.byte	0x9f
 847 00c9 04        		.byte	0x4
 848 00ca 6E        		.uleb128 .LVL15-.Ltext0
 849 00cb 74        		.uleb128 .LVL16-.Ltext0
 850 00cc 01        		.uleb128 0x1
 851 00cd 53        		.byte	0x53
 852 00ce 04        		.byte	0x4
 853 00cf 74        		.uleb128 .LVL16-.Ltext0
 854 00d0 8601      		.uleb128 .LVL19-.Ltext0
 855 00d2 03        		.uleb128 0x3
 856 00d3 73        		.byte	0x73
 857 00d4 01        		.sleb128 1
 858 00d5 9F        		.byte	0x9f
 859 00d6 04        		.byte	0x4
 860 00d7 8601      		.uleb128 .LVL19-.Ltext0
 861 00d9 8601      		.uleb128 .LVL19-.Ltext0
 862 00db 01        		.uleb128 0x1
 863 00dc 53        		.byte	0x53
 864 00dd 04        		.byte	0x4
 865 00de 8601      		.uleb128 .LVL19-.Ltext0
 866 00e0 8A01      		.uleb128 .LVL20-.Ltext0
 867 00e2 03        		.uleb128 0x3
 868 00e3 73        		.byte	0x73
 869 00e4 7F        		.sleb128 -1
 870 00e5 9F        		.byte	0x9f
 871 00e6 00        		.byte	0
 872               	.Ldebug_loc3:
 873               		.section	.debug_aranges,"",@progbits
 874 0000 0000 001C 		.long	0x1c
 875 0004 0002      		.word	0x2
 876 0006 0000 0000 		.long	.Ldebug_info0
 877 000a 04        		.byte	0x4
 878 000b 00        		.byte	0
 879 000c 0000      		.word	0
 880 000e 0000      		.word	0
 881 0010 0000 0000 		.long	.Ltext0
 882 0014 0000 00E6 		.long	.Letext0-.Ltext0


 883 0018 0000 0000 		.long	0
 884 001c 0000 0000 		.long	0
 885               		.section	.debug_line,"",@progbits
 886               	.Ldebug_line0:
 887 0000 0000 0114 		.section	.debug_str,"MS",@progbits,1
 887      0003 0000 
 887      0020 0201 
 887      FB0E 0D00 
 887      0101 0101 
 888               	.LASF0:
 889 0000 6F75 7462 		.string	"outbyte"
 889      7974 6500 
 890               	.LASF4:
 891 0008 6E62 7974 		.string	"nbytes"
 891      6573 00
 892               	.LASF9:
 893 000f 7265 6164 		.string	"read"
 893      00
 894               	.LASF3:
 895 0014 6368 6172 		.string	"char"
 895      00
 896               	.LASF6:
 897 0019 6373 7973 		.string	"csys68k.c"
 897      3638 6B2E 
 897      6300 
 898               	.LASF5:
 899 0023 474E 5520 		.string	"GNU C17 11.4.0 -mcpu=68000 -msoft-float -g -O2 -fomit-frame-pointer"
 899      4331 3720 
 899      3131 2E34 
 899      2E30 202D 
 899      6D63 7075 
 900               	.LASF2:
 901 0067 756E 7369 		.string	"unsigned char"
 901      676E 6564 
 901      2063 6861 
 901      7200 
 902               	.LASF8:
 903 0075 7772 6974 		.string	"write"
 903      6500 
 904               	.LASF7:
 905 007b 2F68 6F6D 		.string	"/home/students/5233566329/software-exp/1_transplant-C-library_compiled"
 905      652F 7374 
 905      7564 656E 
 905      7473 2F35 
 905      3233 3335 
 906               	.LASF1:
 907 00c2 696E 6279 		.string	"inbyte"
 907      7465 00
 908               		.ident	"GCC: (GNU) 11.4.0"




   1               	#NO_APP
   2               		.file	"test1.c"
   3               		.text
   4               	.Ltext0:
   5               		.cfi_sections	.debug_frame
   6               		.section	.rodata.str1.1,"aMS",@progbits,1
   7               	.LC0:
   8 0000 2563 00   		.string	"%c"
   9               		.section	.text.startup,"ax",@progbits
  10               		.align	2
  11               		.globl	main
  12               		.type	main, @function
  13               	main:
  14               	.LFB0:
  15               		.file 1 "test1.c"
   1:test1.c       **** int main(void){
  16               		.loc 1 1 15 view -0
  17               		.cfi_startproc
  18 0000 598F      		subq.l #4,%sp
  19               		.cfi_def_cfa_offset 8
  20 0002 48E7 2030 		movem.l #8240,-(%sp)
  21               		.cfi_def_cfa_offset 20
  22               		.cfi_offset 2, -20
  23               		.cfi_offset 10, -16
  24               		.cfi_offset 11, -12
  25 0006 740F      		moveq #15,%d2
  26 0008 D48F      		add.l %sp,%d2
  27 000a 47F9 0000 		lea scanf,%a3
  27      0000 
  28 0010 45F9 0000 		lea putchar,%a2
  28      0000 
  29               	.L2:
   2:test1.c       ****     char c;
  30               		.loc 1 2 5 discriminator 1 view .LVU1
   3:test1.c       ****     while(1){
  31               		.loc 1 3 5 discriminator 1 view .LVU2
  32               	.LBB2:
   4:test1.c       ****         scanf("%c", &c);
  33               		.loc 1 4 9 discriminator 1 view .LVU3
  34 0016 2F02      		move.l %d2,-(%sp)
  35               		.cfi_def_cfa_offset 24
  36 0018 4879 0000 		pea .LC0
  36      0000 
  37               		.cfi_def_cfa_offset 28
  38 001e 4E93      		jsr (%a3)
  39               	.LVL0:
   5:test1.c       ****         printf("%c", c);
  40               		.loc 1 5 9 discriminator 1 view .LVU4
  41 0020 102F 0017 		move.b 23(%sp),%d0
  42 0024 4880      		ext.w %d0
  43 0026 3040      		move.w %d0,%a0
  44 0028 2F08      		move.l %a0,-(%sp)
  45               		.cfi_def_cfa_offset 32
  46 002a 4E92      		jsr (%a2)
  47               	.LVL1:
  48               	.LBE2:
   3:test1.c       ****     while(1){


  49               		.loc 1 3 10 discriminator 1 view .LVU5
  50               	.LBB3:
  51               		.loc 1 5 9 is_stmt 0 discriminator 1 view .LVU6
  52 002c 4FEF 000C 		lea (12,%sp),%sp
  53               		.cfi_def_cfa_offset 20
  54               	.LBE3:
   2:test1.c       ****         scanf("%c", &c);
  55               		.loc 1 2 5 is_stmt 1 discriminator 1 view .LVU7
   3:test1.c       ****         printf("%c", c);
  56               		.loc 1 3 5 discriminator 1 view .LVU8
  57               	.LBB4:
   4:test1.c       ****     }
  58               		.loc 1 4 9 discriminator 1 view .LVU9
  59 0030 2F02      		move.l %d2,-(%sp)
  60               		.cfi_def_cfa_offset 24
  61 0032 4879 0000 		pea .LC0
  61      0000 
  62               		.cfi_def_cfa_offset 28
  63 0038 4E93      		jsr (%a3)
  64               	.LVL2:
  65               		.loc 1 5 9 discriminator 1 view .LVU10
  66 003a 102F 0017 		move.b 23(%sp),%d0
  67 003e 4880      		ext.w %d0
  68 0040 3040      		move.w %d0,%a0
  69 0042 2F08      		move.l %a0,-(%sp)
  70               		.cfi_def_cfa_offset 32
  71 0044 4E92      		jsr (%a2)
  72               	.LVL3:
  73               	.LBE4:
   3:test1.c       ****         printf("%c", c);
  74               		.loc 1 3 10 discriminator 1 view .LVU11
  75               	.LBB5:
  76               		.loc 1 5 9 is_stmt 0 discriminator 1 view .LVU12
  77 0046 4FEF 000C 		lea (12,%sp),%sp
  78               		.cfi_def_cfa_offset 20
  79 004a 60CA      		jra .L2
  80               	.LBE5:
  81               		.cfi_endproc
  82               	.LFE0:
  83               		.size	main, .-main
  84               		.text
  85               	.Letext0:
  86               		.file 2 "<built-in>"
  87               		.section	.debug_info,"",@progbits
  88               	.Ldebug_info0:
  89 0000 0000 00C8 		.long	0xc8
  90 0004 0005      		.word	0x5
  91 0006 01        		.byte	0x1
  92 0007 04        		.byte	0x4
  93 0008 0000 0000 		.long	.Ldebug_abbrev0
  94 000c 06        		.uleb128 0x6
  95 000d 0000 0000 		.long	.LASF6
  96 0011 1D        		.byte	0x1d
  97 0012 0000 0000 		.long	.LASF7
  98 0016 0000 0000 		.long	.LASF8
  99 001a 0000 0000 		.long	.LLRL1
 100 001e 0000 0000 		.long	0


 101 0022 0000 0000 		.long	.Ldebug_line0
 102 0026 07        		.uleb128 0x7
 103 0027 0000 0000 		.long	.LASF9
 104 002b 01        		.byte	0x1
 105 002c 01        		.byte	0x1
 106 002d 05        		.byte	0x5
 107 002e 0000 00A0 		.long	0xa0
 108 0032 0000 0000 		.long	.LFB0
 109 0036 0000 004C 		.long	.LFE0-.LFB0
 110 003a 01        		.uleb128 0x1
 111 003b 9C        		.byte	0x9c
 112 003c 0000 00A0 		.long	0xa0
 113 0040 08        		.uleb128 0x8
 114 0041 6300      		.string	"c"
 115 0043 01        		.byte	0x1
 116 0044 02        		.byte	0x2
 117 0045 0A        		.byte	0xa
 118 0046 0000 00A7 		.long	0xa7
 119 004a 02        		.uleb128 0x2
 120 004b 91        		.byte	0x91
 121 004c 7B        		.sleb128 -5
 122 004d 09        		.uleb128 0x9
 123 004e 0000 0000 		.long	.LLRL0
 124 0052 02        		.uleb128 0x2
 125 0053 0000 0000 		.long	.LASF0
 126 0057 0000 00A0 		.long	0xa0
 127 005b 0000 0066 		.long	0x66
 128 005f 03        		.uleb128 0x3
 129 0060 0000 00B3 		.long	0xb3
 130 0064 04        		.uleb128 0x4
 131 0065 00        		.byte	0
 132 0066 02        		.uleb128 0x2
 133 0067 0000 0000 		.long	.LASF1
 134 006b 0000 00A0 		.long	0xa0
 135 006f 0000 007A 		.long	0x7a
 136 0073 03        		.uleb128 0x3
 137 0074 0000 00B3 		.long	0xb3
 138 0078 04        		.uleb128 0x4
 139 0079 00        		.byte	0
 140 007a 01        		.uleb128 0x1
 141 007b 0000 0000 		.long	.LVL0
 142 007f 0000 00B9 		.long	0xb9
 143 0083 01        		.uleb128 0x1
 144 0084 0000 0000 		.long	.LVL1
 145 0088 0000 00C2 		.long	0xc2
 146 008c 01        		.uleb128 0x1
 147 008d 0000 0000 		.long	.LVL2
 148 0091 0000 00B9 		.long	0xb9
 149 0095 01        		.uleb128 0x1
 150 0096 0000 0000 		.long	.LVL3
 151 009a 0000 00C2 		.long	0xc2
 152 009e 00        		.byte	0
 153 009f 00        		.byte	0
 154 00a0 0A        		.uleb128 0xa
 155 00a1 04        		.byte	0x4
 156 00a2 05        		.byte	0x5
 157 00a3 696E 7400 		.string	"int"


 158 00a7 0B        		.uleb128 0xb
 159 00a8 01        		.byte	0x1
 160 00a9 06        		.byte	0x6
 161 00aa 0000 0000 		.long	.LASF2
 162 00ae 0C        		.uleb128 0xc
 163 00af 0000 00A7 		.long	0xa7
 164 00b3 0D        		.uleb128 0xd
 165 00b4 04        		.byte	0x4
 166 00b5 0000 00AE 		.long	0xae
 167 00b9 05        		.uleb128 0x5
 168 00ba 0000 0000 		.long	.LASF0
 169 00be 0000 0000 		.long	.LASF4
 170 00c2 05        		.uleb128 0x5
 171 00c3 0000 0000 		.long	.LASF3
 172 00c7 0000 0000 		.long	.LASF5
 173 00cb 00        		.byte	0
 174               		.section	.debug_abbrev,"",@progbits
 175               	.Ldebug_abbrev0:
 176 0000 01        		.uleb128 0x1
 177 0001 48        		.uleb128 0x48
 178 0002 00        		.byte	0
 179 0003 7D        		.uleb128 0x7d
 180 0004 01        		.uleb128 0x1
 181 0005 7F        		.uleb128 0x7f
 182 0006 13        		.uleb128 0x13
 183 0007 00        		.byte	0
 184 0008 00        		.byte	0
 185 0009 02        		.uleb128 0x2
 186 000a 2E        		.uleb128 0x2e
 187 000b 01        		.byte	0x1
 188 000c 3F        		.uleb128 0x3f
 189 000d 19        		.uleb128 0x19
 190 000e 03        		.uleb128 0x3
 191 000f 0E        		.uleb128 0xe
 192 0010 3A        		.uleb128 0x3a
 193 0011 21        		.uleb128 0x21
 194 0012 02        		.sleb128 2
 195 0013 3B        		.uleb128 0x3b
 196 0014 21        		.uleb128 0x21
 197 0015 00        		.sleb128 0
 198 0016 27        		.uleb128 0x27
 199 0017 19        		.uleb128 0x19
 200 0018 49        		.uleb128 0x49
 201 0019 13        		.uleb128 0x13
 202 001a 3C        		.uleb128 0x3c
 203 001b 19        		.uleb128 0x19
 204 001c 01        		.uleb128 0x1
 205 001d 13        		.uleb128 0x13
 206 001e 00        		.byte	0
 207 001f 00        		.byte	0
 208 0020 03        		.uleb128 0x3
 209 0021 05        		.uleb128 0x5
 210 0022 00        		.byte	0
 211 0023 49        		.uleb128 0x49
 212 0024 13        		.uleb128 0x13
 213 0025 00        		.byte	0
 214 0026 00        		.byte	0


 215 0027 04        		.uleb128 0x4
 216 0028 18        		.uleb128 0x18
 217 0029 00        		.byte	0
 218 002a 00        		.byte	0
 219 002b 00        		.byte	0
 220 002c 05        		.uleb128 0x5
 221 002d 2E        		.uleb128 0x2e
 222 002e 00        		.byte	0
 223 002f 3F        		.uleb128 0x3f
 224 0030 19        		.uleb128 0x19
 225 0031 3C        		.uleb128 0x3c
 226 0032 19        		.uleb128 0x19
 227 0033 6E        		.uleb128 0x6e
 228 0034 0E        		.uleb128 0xe
 229 0035 03        		.uleb128 0x3
 230 0036 0E        		.uleb128 0xe
 231 0037 3A        		.uleb128 0x3a
 232 0038 21        		.uleb128 0x21
 233 0039 02        		.sleb128 2
 234 003a 3B        		.uleb128 0x3b
 235 003b 21        		.uleb128 0x21
 236 003c 00        		.sleb128 0
 237 003d 00        		.byte	0
 238 003e 00        		.byte	0
 239 003f 06        		.uleb128 0x6
 240 0040 11        		.uleb128 0x11
 241 0041 01        		.byte	0x1
 242 0042 25        		.uleb128 0x25
 243 0043 0E        		.uleb128 0xe
 244 0044 13        		.uleb128 0x13
 245 0045 0B        		.uleb128 0xb
 246 0046 03        		.uleb128 0x3
 247 0047 0E        		.uleb128 0xe
 248 0048 1B        		.uleb128 0x1b
 249 0049 0E        		.uleb128 0xe
 250 004a 55        		.uleb128 0x55
 251 004b 17        		.uleb128 0x17
 252 004c 11        		.uleb128 0x11
 253 004d 01        		.uleb128 0x1
 254 004e 10        		.uleb128 0x10
 255 004f 17        		.uleb128 0x17
 256 0050 00        		.byte	0
 257 0051 00        		.byte	0
 258 0052 07        		.uleb128 0x7
 259 0053 2E        		.uleb128 0x2e
 260 0054 01        		.byte	0x1
 261 0055 3F        		.uleb128 0x3f
 262 0056 19        		.uleb128 0x19
 263 0057 03        		.uleb128 0x3
 264 0058 0E        		.uleb128 0xe
 265 0059 3A        		.uleb128 0x3a
 266 005a 0B        		.uleb128 0xb
 267 005b 3B        		.uleb128 0x3b
 268 005c 0B        		.uleb128 0xb
 269 005d 39        		.uleb128 0x39
 270 005e 0B        		.uleb128 0xb
 271 005f 27        		.uleb128 0x27


 272 0060 19        		.uleb128 0x19
 273 0061 49        		.uleb128 0x49
 274 0062 13        		.uleb128 0x13
 275 0063 11        		.uleb128 0x11
 276 0064 01        		.uleb128 0x1
 277 0065 12        		.uleb128 0x12
 278 0066 06        		.uleb128 0x6
 279 0067 40        		.uleb128 0x40
 280 0068 18        		.uleb128 0x18
 281 0069 7A        		.uleb128 0x7a
 282 006a 19        		.uleb128 0x19
 283 006b 01        		.uleb128 0x1
 284 006c 13        		.uleb128 0x13
 285 006d 00        		.byte	0
 286 006e 00        		.byte	0
 287 006f 08        		.uleb128 0x8
 288 0070 34        		.uleb128 0x34
 289 0071 00        		.byte	0
 290 0072 03        		.uleb128 0x3
 291 0073 08        		.uleb128 0x8
 292 0074 3A        		.uleb128 0x3a
 293 0075 0B        		.uleb128 0xb
 294 0076 3B        		.uleb128 0x3b
 295 0077 0B        		.uleb128 0xb
 296 0078 39        		.uleb128 0x39
 297 0079 0B        		.uleb128 0xb
 298 007a 49        		.uleb128 0x49
 299 007b 13        		.uleb128 0x13
 300 007c 02        		.uleb128 0x2
 301 007d 18        		.uleb128 0x18
 302 007e 00        		.byte	0
 303 007f 00        		.byte	0
 304 0080 09        		.uleb128 0x9
 305 0081 0B        		.uleb128 0xb
 306 0082 01        		.byte	0x1
 307 0083 55        		.uleb128 0x55
 308 0084 17        		.uleb128 0x17
 309 0085 00        		.byte	0
 310 0086 00        		.byte	0
 311 0087 0A        		.uleb128 0xa
 312 0088 24        		.uleb128 0x24
 313 0089 00        		.byte	0
 314 008a 0B        		.uleb128 0xb
 315 008b 0B        		.uleb128 0xb
 316 008c 3E        		.uleb128 0x3e
 317 008d 0B        		.uleb128 0xb
 318 008e 03        		.uleb128 0x3
 319 008f 08        		.uleb128 0x8
 320 0090 00        		.byte	0
 321 0091 00        		.byte	0
 322 0092 0B        		.uleb128 0xb
 323 0093 24        		.uleb128 0x24
 324 0094 00        		.byte	0
 325 0095 0B        		.uleb128 0xb
 326 0096 0B        		.uleb128 0xb
 327 0097 3E        		.uleb128 0x3e
 328 0098 0B        		.uleb128 0xb


 329 0099 03        		.uleb128 0x3
 330 009a 0E        		.uleb128 0xe
 331 009b 00        		.byte	0
 332 009c 00        		.byte	0
 333 009d 0C        		.uleb128 0xc
 334 009e 26        		.uleb128 0x26
 335 009f 00        		.byte	0
 336 00a0 49        		.uleb128 0x49
 337 00a1 13        		.uleb128 0x13
 338 00a2 00        		.byte	0
 339 00a3 00        		.byte	0
 340 00a4 0D        		.uleb128 0xd
 341 00a5 0F        		.uleb128 0xf
 342 00a6 00        		.byte	0
 343 00a7 0B        		.uleb128 0xb
 344 00a8 0B        		.uleb128 0xb
 345 00a9 49        		.uleb128 0x49
 346 00aa 13        		.uleb128 0x13
 347 00ab 00        		.byte	0
 348 00ac 00        		.byte	0
 349 00ad 00        		.byte	0
 350               		.section	.debug_aranges,"",@progbits
 351 0000 0000 001C 		.long	0x1c
 352 0004 0002      		.word	0x2
 353 0006 0000 0000 		.long	.Ldebug_info0
 354 000a 04        		.byte	0x4
 355 000b 00        		.byte	0
 356 000c 0000      		.word	0
 357 000e 0000      		.word	0
 358 0010 0000 0000 		.long	.LFB0
 359 0014 0000 004C 		.long	.LFE0-.LFB0
 360 0018 0000 0000 		.long	0
 361 001c 0000 0000 		.long	0
 362               		.section	.debug_rnglists,"",@progbits
 363               	.Ldebug_ranges0:
 364 0000 0000 0021 		.long	.Ldebug_ranges3-.Ldebug_ranges2
 365               	.Ldebug_ranges2:
 366 0004 0005      		.word	0x5
 367 0006 04        		.byte	0x4
 368 0007 00        		.byte	0
 369 0008 0000 0000 		.long	0
 370               	.LLRL0:
 371 000c 05        		.byte	0x5
 372 000d 0000 0000 		.long	.LBB2
 373 0011 04        		.byte	0x4
 374 0012 00        		.uleb128 .LBB2-.LBB2
 375 0013 16        		.uleb128 .LBE2-.LBB2
 376 0014 04        		.byte	0x4
 377 0015 16        		.uleb128 .LBB3-.LBB2
 378 0016 1A        		.uleb128 .LBE3-.LBB2
 379 0017 04        		.byte	0x4
 380 0018 1A        		.uleb128 .LBB4-.LBB2
 381 0019 30        		.uleb128 .LBE4-.LBB2
 382 001a 04        		.byte	0x4
 383 001b 30        		.uleb128 .LBB5-.LBB2
 384 001c 36        		.uleb128 .LBE5-.LBB2
 385 001d 00        		.byte	0


 386               	.LLRL1:
 387 001e 07        		.byte	0x7
 388 001f 0000 0000 		.long	.LFB0
 389 0023 4C        		.uleb128 .LFE0-.LFB0
 390 0024 00        		.byte	0
 391               	.Ldebug_ranges3:
 392               		.section	.debug_line,"",@progbits
 393               	.Ldebug_line0:
 394 0000 0000 0090 		.section	.debug_str,"MS",@progbits,1
 394      0003 0000 
 394      002C 0201 
 394      FB0E 0D00 
 394      0101 0101 
 395               	.LASF3:
 396 0000 7075 7463 		.string	"putchar"
 396      6861 7200 
 397               	.LASF0:
 398 0008 7363 616E 		.string	"scanf"
 398      6600 
 399               	.LASF7:
 400 000e 7465 7374 		.string	"test1.c"
 400      312E 6300 
 401               	.LASF2:
 402 0016 6368 6172 		.string	"char"
 402      00
 403               	.LASF6:
 404 001b 474E 5520 		.string	"GNU C17 11.4.0 -mcpu=68000 -msoft-float -g -O2 -fomit-frame-pointer"
 404      4331 3720 
 404      3131 2E34 
 404      2E30 202D 
 404      6D63 7075 
 405               	.LASF9:
 406 005f 6D61 696E 		.string	"main"
 406      00
 407               	.LASF5:
 408 0064 5F5F 6275 		.string	"__builtin_putchar"
 408      696C 7469 
 408      6E5F 7075 
 408      7463 6861 
 408      7200 
 409               	.LASF8:
 410 0076 2F68 6F6D 		.string	"/home/students/5233566329/software-exp/1_transplant-C-library_compiled"
 410      652F 7374 
 410      7564 656E 
 410      7473 2F35 
 410      3233 3335 
 411               	.LASF4:
 412 00bd 5F5F 6275 		.string	"__builtin_scanf"
 412      696C 7469 
 412      6E5F 7363 
 412      616E 6600 
 413               	.LASF1:
 414 00cd 7072 696E 		.string	"printf"
 414      7466 00
 415               		.ident	"GCC: (GNU) 11.4.0"


